#!/bin/bash

#####
# esg-node: ESG Data Node Application Stack
# chkconfig: 345 98 02
# description: Installer for the ESG Data Node application stack
#
#****************************************************************************
#*                                                                          *
#*  Organization: Lawrence Livermore National Lab (LLNL)                    *
#*   Directorate: Computation                                               *
#*    Department: Computing Applications and Research                       *
#*      Division: S&T Global Security                                       *
#*        Matrix: Atmospheric, Earth and Energy Division                    *
#*       Program: PCMDI                                                     *
#*       Project: Earth Systems Grid (ESG) Data Node Software Stack         *
#*  First Author: Gavin M. Bell (gavin@llnl.gov)                            *
#*                                                                          *
#****************************************************************************
#*                                                                          *
#*   Copyright (c) 2009, Lawrence Livermore National Security, LLC.         *
#*   Produced at the Lawrence Livermore National Laboratory                 *
#*   Written by: Gavin M. Bell (gavin@llnl.gov)                             *
#*   LLNL-CODE-420962                                                       *
#*                                                                          *
#*   All rights reserved. This file is part of the:                         *
#*   Earth System Grid (ESG) Data Node Software Stack, Version 1.0          *
#*                                                                          *
#*   For details, see http://esg-repo.llnl.gov/esg-node/                    *
#*   Please also read this link                                             *
#*    http://esg-repo.llnl.gov/LICENSE                                      *
#*                                                                          *
#*   * Redistribution and use in source and binary forms, with or           *
#*   without modification, are permitted provided that the following        *
#*   conditions are met:                                                    *
#*                                                                          *
#*   * Redistributions of source code must retain the above copyright       *
#*   notice, this list of conditions and the disclaimer below.              *
#*                                                                          *
#*   * Redistributions in binary form must reproduce the above copyright    *
#*   notice, this list of conditions and the disclaimer (as noted below)    *
#*   in the documentation and/or other materials provided with the          *
#*   distribution.                                                          *
#*                                                                          *
#*   Neither the name of the LLNS/LLNL nor the names of its contributors    *
#*   may be used to endorse or promote products derived from this           *
#*   software without specific prior written permission.                    *
#*                                                                          *
#*   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    *
#*   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT      *
#*   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS      *
#*   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL LAWRENCE    *
#*   LIVERMORE NATIONAL SECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR     *
#*   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,           *
#*   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT       *
#*   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF       *
#*   USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND    *
#*   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,     *
#*   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT     *
#*   OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF     *
#*   SUCH DAMAGE.                                                           *
#*                                                                          *
#****************************************************************************
#####

#uses: perl, awk, ifconfig, tar, wget, curl, su, useradd, groupadd,
#      id, chmod, chown, chgrp, cut, svn, mkdir, killall, java, egrep,
#      lsof, unlink, ln, pax, keytool, openssl

#note: usage of readlink not macosx friendly :-( usage of useradd /
#      groupadd is RedHat/CentOS dependent :-(

DEBUG=${DEBUG:-0}
VERBOSE=${VERBOSE:-0}
progname=esg-node
version="0.9.0"
envfile="/etc/esg.env"

#--------------
#User Defined / Settable (public)
#--------------
t=${0%.*}
logfile=${logfile:-"/var/tmp/${t##*/}.out"}
install_prefix=${install_prefix:-"/usr/local"}
esg_root_dir=${esg_root_dir:-"/esg"}
esg_config_type_file=${esg_root_dir}/config/config_type
pg_secret_file=${esg_root_dir}/config/.esg_pg_pass
ks_secret_file=${esg_root_dir}/config/.esg_keystore_pass
workdir=${workdir:-~/workbench/esg}
install_logfile=${install_logfile:-"/etc/esg.install_log"}
#--------------


init() {
    [ -e "${envfile}" ] && source ${envfile} && ((VERBOSE)) && printf "sourcing environment from: ${envfile} \n"

    #--------------------------------
    # Internal data-node code versions and supporting external libraries
    #--------------------------------
    #cdat_version=${cdat_version:-"eb8b668"}
    cdat_version=${cdat_version:-"4.0.0"}
    esgcet_version=${esgcet_version:-"2.7.3"}
    esgcet_python_version=${esgcet_python_version:-"2.6"}
    node_version=${node_version:-"0.9.0"}

    #see esg-orp project:
    esg_orp_version=${orp_version:-"1.0.1"}

    #see esgf-security project:
    esgf_security_version=${esg_saml_version:-"1.0.2"}
    opensaml_version=${opensaml_version:-"2.3.2"}
    openws_version=${openws_version:-"1.3.1"}
    xmltooling_version=${xmltooling_version:-"1.2.2"}
    xsgroup_role_version=${xsgroup_role_version:-"1.0.0"}
    
    #--------------------------------
    # External programs' versions
    #--------------------------------
    curl_version=${curl_version:="7.20.1"}
    git_version=${git_version:="1.7.3"}
    java_version=${java_version:-"1.6.0_20"}
    ant_version=${ant_version:-"1.8.1"}
    postgress_version=${postgress_version:-"8.4.5"}
    tomcat_version=${tomcat_version:-"6.0.29"}
    tds_version=${tds_version:-"4.2.20100908.2246"}

    #--------------------------------
    # Script vars (~external)
    #--------------------------------
    curl_install_dir=${CURL_HOME:-${install_prefix}/curl}
    git_install_dir=${GIT_HOME:-${install_prefix}/git}
    postgress_install_dir=${PGHOME:-${install_prefix}/pgsql}
    postgress_user=${PGUSER:-dbsuper}
    local pg_secret=$(cat ${pg_secret_file} 2> /dev/null)
    pg_sys_acct_passwd=${pg_sys_acct_passwd:=${pg_secret:=changeme}}
    unset pg_secret #only here to hold the tertiary ephemeral value from file, unset asap
    postgress_host=${PGHOST:-localhost}
    postgress_port=${PGPORT:-5432}
    cdat_home=${CDAT_HOME:-${install_prefix}/cdat}
    java_opts=${JAVA_OPTS:-"-Xmx2048m -Xms1024m"}
    java_install_dir=${JAVA_HOME:-${install_prefix}/java}
    ant_install_dir=${ANT_HOME:-${install_prefix}/ant}
    tomcat_install_dir=${CATALINA_HOME:-${install_prefix}/tomcat}
    tomcat_conf_dir=${tomcat_install_dir}/conf
    #tomcat_conf_dir=${esg_root_dir}/config/tomcat
    tomcat_opts=${CATALINA_OPTS}
    tomcat_user=${tomcat_user:-tomcat}
    tomcat_group=${tomcat_group:-$tomcat_user}
    globus_location=${GLOBUS_LOCATION:-${install_prefix}/globus}
    gateway_name=${ESG_GATEWAY_NAME}
    gateway_service_root=${ESG_GATEWAY_SVC_ROOT}
    myproxy_endpoint=${myproxy_endpoint:-${gateway_service_root%%/*}}
    myproxy_port=${myproxy_port:-7512}
    esg_root_id=${ESG_ROOT_ID:-$(echo `hostname -s`.`hostname --domain` | awk -F. ' {print $(NF-1)} ')}
    mail_smtp_host=${mail_smtp_host:-smtp.`hostname --domain`} #standard guess.
    mail_admin_address=${mail_admin_address}
    gridftp_config_args=${gridftp_config_args:-""}
    
    ############################################
    ####  DO NOT EDIT BELOW THIS POINT!!!!! ####
    ############################################
    
    export CURL_HOME=${curl_install_dir}
    export GIT_HOME=${git_install_dir}
    export PGHOME=${postgress_install_dir}
    export PGUSER=${postgress_user}
    export PGHOST=${postgress_host}
    export PGPORT=${postgress_port}
    export CDAT_HOME=${cdat_home}
    export JAVA_HOME=${java_install_dir}
    export JAVA_OPTS=${java_opts}
    export ANT_HOME=${ant_install_dir}
    export CATALINA_HOME=${tomcat_install_dir}
    export CATALINA_BASE=${CATALINA_HOME}
    export CATALINA_OPTS=${tomcat_opts}
    export GLOBUS_LOCATION=${globus_location}
    export X509_CERT_DIR=${X509_CERT_DIR:-${HOME}/.globus/certificates-esg}
    export ESG_ROOT_ID=${esg_root_id}
    
    myPATH=${install_prefix}/bin:$CURL_HOME/bin:$GIT_HOME/bin:$JAVA_HOME/bin:$ANT_HOME/bin:$PGHOME/bin:$CDAT_HOME/bin:$CDAT_HOME/Externals/bin:$CATALINA_HOME/bin:$GLOBUS_LOCATION/bin:/bin:/sbin:/usr/bin:/usr/sbin
    myLD_LIBRARY_PATH=$CURL_HOME/lib:$PGHOME/lib:$CDAT_HOME/Externals/lib:$GLOBUS_LOCATION/lib
    export PATH=$myPATH:$PATH
    export LD_LIBRARY_PATH=$myLD_LIBRARY_PATH:$LD_LIBRARY_PATH
    export CFLAGS="-I$CURL_HOME/include $CFLAGS"
    export LDFLAGS="-L$CURL_HOME/lib"
    
    #--------------
    # ID Setting
    #--------------
    #Yes, I could make this more cleaver and not call id twice but use
    #a single sed expression with two capture groups and then assign
    #them accordingly... but sadly I have to brush up on my sed'ing
    #:-\ But this works... Basically the installer id is based on the
    #$HOME directory of this user

    installer_uid=$(id ${HOME##*/} | sed 's/.*uid=\([0-9]*\).*/\1/')
    [ $? != 0 ] || [ -z "$installer_uid" ] && echo "installer_uid is not set" && exit 1
    installer_gid=$(id ${HOME##*/} | sed 's/.*gid=\([0-9]*\).*/\1/')
    [ $? != 0 ] || [ -z "$installer_gid" ] && echo "installer_gid is not set" && exit 1
    installer_home=${HOME}

    ((VERBOSE)) && echo "${installer_uid}:${installer_gid}:${installer_home}"

    #--------------
    # Script vars (internal)
    #--------------
    esg_backup_dir=${esg_backup_dir:-"${esg_root_dir}/backups"}
    esg_config_dir=${esg_config_dir:-"${esg_root_dir}/config"}
    esg_log_dir=${esg_log_dir:-"${esg_root_dir}/log"}
    esg_tools_dir=${esg_tools_dir:-"${esg_root_dir}/tools"}

    word_size=${word_size:-$(file /bin/bash | perl -ple 's/^.*ELF\s*(32|64)-bit.*$/$1/g')}
    esg_dist_url=http://198.128.245.140/dist
    date_format="+%Y_%m_%d_%H%M%S"
    num_backups_to_keep=${num_backups_to_keep:-7}
    compress_extensions=".tar.gz|.tar.bz2|.tgz|.bz2"
    certificate_extensions="pem|crt|cert|key"
    java_dist_url=${esg_dist_url}/java/${java_version}/jdk${java_version}-${word_size}.tar.gz
    ant_dist_url=http://www.trieuvan.com/apache/ant/binaries/apache-ant-${ant_version}-bin.tar.gz
    curl_workdir=${workdir}/curl
    curl_dist_url=http://curl.haxx.se/download/curl-${curl_version}.tar.gz
    git_workdir=${workdir}/git
    git_dist_url=http://kernel.org/pub/software/scm/git/git-${git_version}.tar.gz
    postgress_workdir=${workdir}/postgress
    postgress_jar=postgresql-8.3-603.jdbc3.jar
    postgress_driver=org.postgresql.Driver
    postgress_protocol=jdbc:postgresql:
    pg_sys_acct=${pg_sys_acct:-postgres}
    pg_sys_acct_group=${pg_sys_acct_group:-$pg_sys_acct}
    postgress_dist_url=http://ftp9.us.postgresql.org/pub/mirrors/postgresql/source/v${postgress_version}/postgresql-${postgress_version}.tar.gz
    cdat_repo=git://uv-cdat.llnl.gov/cdat.git
    cdat_repo_http=http://uv-cdat.llnl.gov/git/cdat.git
    esgcet_egg_file=esgcet-${esgcet_version}-py${esgcet_python_version}.egg
    esg_testdir=${workdir}/../esg_test
    tomcat_dist_url=http://download.filehat.com/apache/tomcat/tomcat-6/v${tomcat_version}/bin/apache-tomcat-${tomcat_version}.tar.gz
    tomcat_pid_file=/var/run/tomcat-jsvc.pid
    utils_url=${esg_dist_url}/utils
    thredds_dist_url=ftp://ftp.unidata.ucar.edu/pub/thredds/${tds_version}/thredds.war
    thredds_esg_dist_url=${esg_dist_url}/thredds/${tds_version}/thredds.war
    thredds_content_dir=${thredds_content_dir:-${esg_root_dir}/content}
    #NOTE: This root dir should match a root set in the thredds setup 
    thredds_root_dir=${esg_root_dir}/data
    thredds_replica_dir=${thredds_root_dir}/replica
    node_dist_url=${esg_dist_url}/esg-node/esg-node.${node_version}.tar.gz
    node_db_name=esgcet
    node_app_context_root=esg-node
    node_app_home=${tomcat_install_dir}/webapps/${node_app_context_root}
    #NOTE: This is another RedHat/CentOS specific portion!!! it will break on another OS!
    my_ip_address=$(ifconfig | grep "inet[^6]" | awk '$0 !~ /127.0.0.1/ { gsub (" *inet [^:]*:",""); print $1}')
    show_summary_latch=0
    source_latch=0
    node_host_ip_address=${my_ip_address}
    scripts_dir=${install_prefix}/bin
    no_globus=${no_globus:-0}
    force_install=${force_install:-0}
    extkeytool_download_url=${esg_dist_url}/etc/idptools.tar.gz
    tomcat_users_file=${tomcat_conf_dir}/tomcat-users.xml
    keystore_file=${tomcat_conf_dir}/keystore-tomcat
    keystore_alias=my_esgf_node
    keystore_password=changeit
    truststore_file=${tomcat_conf_dir}/esg-truststore.ts
    globus_global_certs_dir=/etc/grid-security/certificates
    #NOTE: java keystore style DN...
    dname=${dname:-"OU=simpleCA-pcmdi3.llnl.gov, OU=GlobusTest, O=Grid"}

    mkdir -p ${scripts_dir}
    [ $? != 0 ] && echo "ERROR: could not create ${scripts_dir}... required for installation" && checked_done 1

    mkdir -p ${esg_backup_dir}  && \
        mkdir -p ${esg_tools_dir} && \
        mkdir -p ${esg_log_dir} && \
        mkdir -p ${esg_config_dir} && \
        mkdir -p ${tomcat_conf_dir}
    [ $? != 0 ] && echo "ERROR: could not create ${esg_root_dir} dir and/or subdirectories" && checked_done 1

    [ -w "${envfile}" ] && write_paths
}

write_paths() {
    ((show_summary_latch++))
    echo "export PATH=$myPATH:\$PATH" >> ${envfile}
    echo "export LD_LIBRARY_PATH=$myLD_LIBRARY_PATH:\$LD_LIBRARY_PATH" >> ${envfile}
    echo "export ESG_USER_HOME=${installer_home}" >> ${envfile}
    dedup ${envfile} && source ${envfile}
}

#checking for what we expect to be on the system a-priori
#that we are not going to install or be responsible for
check_prerequisites() {
    printf "Checking that you have root privs on $(hostname)... " 
    id | grep root >& /dev/null
    [ $? != 0 ] && printf "[FAIL] \n\tMust run this program with root's effective UID\n\n" && return 1
    echo "[OK]"

    #----------------------------------------
    echo "Checking requisites... "

    ((VERBOSE)) && echo -n "Checking for gmake... "
    gmake --version >& /dev/null
    ((VERBOSE)) && [ $? != 0 ] && echo "[FAIL]" && return 1
    ((VERBOSE)) && echo "[OK]"

    ((VERBOSE)) && echo -n "Checking for X11 libs... "
    Xorg -version >& /dev/null 
    ((VERBOSE)) && ( [ $? != 0 ] && echo "[WARNING] X11 is needed for publisher UI..." || echo "[OK]" )
    #----------------------------------------

    echo
    return 0
}

#####
# Curl/libcurl (support library - needed to support HTTP protocol in GIT)
#####
setup_curl() {

    echo -n "Checking for curl ${curl_version} "
    check_version curl ${curl_version}
    [ $? == 0 ] && (( ! force_install )) && echo " [OK]" && return 0
    
    echo
    echo "*******************************"
    echo "Setting up Curl/Libcurl ${curl_version}"
    echo "*******************************"
    echo
    
    local default="Y"
    ((force_install)) && default="N"
    local dosetup
    if [ -x ${curl_install_dir}/bin/curl ]; then 
        echo "Detected an existing CURL installation..."
        read -p "Do you want to continue with CURL installation and setup? $([ "$default" = "N" ] && echo "[y/N]" || echo "[Y/n]") " dosetup
        [ -z ${dosetup} ] && dosetup=${default}        
        if [ "${dosetup}" != "Y" ] && [ "${dosetup}" != "y" ]; then
            echo "Skipping CURL installation and setup - will assume CURL is setup properly"
            return 0
        fi
        echo
    fi

    mkdir -p ${curl_workdir}
    [ $? != 0 ] && checked_done 1
    chmod a+rw ${curl_workdir}
    pushd ${curl_workdir} >& /dev/null
    
    local curl_dist_file=${curl_dist_url##*/}
    #strip off .tar.gz at the end
    local curl_dist_dir=$(echo ${curl_dist_file} | awk 'gsub(/('$compress_extensions')/,"")')
    
    #There is this pesky case of having a zero sized dist file... WTF!?
    if [ -e ${curl_dist_file} ]; then
        ls -l ${curl_dist_file}
        local size=$(stat -c%s ${curl_dist_file})
        (( size == 0 )) && rm -v ${curl_dist_file}
    fi

    #Check to see if we have postgres distribution directory
    if [ ! -e ${curl_dist_dir} ]; then
        echo "Don't see CURL distribution dir ${curl_dist_dir}"
        if [ ! -e ${curl_dist_file} ]; then
            echo "Don't see CURL distribution file ${curl_dist_file} either"
            echo "Downloading CURL from ${curl_dist_url}"
            wget -O ${curl_dist_file} ${curl_dist_url}
            [ $? != 0 ] && echo " ERROR: Could not download CURL:${curl_dist_file}" && popd && checked_done 1
            echo "unpacking ${curl_dist_file}..."
            tar xzf ${curl_dist_file}
            [ $? != 0 ] && echo " ERROR: Could not extract CURL: ${curl_dist_file}" && popd && checked_done 1
        fi
    fi

    #If you don't see the directory but see the tar.gz distribution
    #then expand it and go from there....
    if [ -e ${curl_dist_file} ] && [ ! -e ${curl_dist_dir} ]; then
        echo "unpacking ${curl_dist_file}..."
        tar xzf ${curl_dist_file}
    fi

    pushd ${curl_dist_dir}
    echo "./configure --prefix=${curl_install_dir}"
    if ./configure --prefix=${curl_install_dir} \
        && gmake all \
        && gmake install 
    then
        echo "Successfully Configured and Built CURL in: ${curl_install_dir}"
        #this is the "test"
        ${curl_install_dir}/bin/curl --version
        [ $? != 0 ] &&  echo" ERROR: Could NOT successfully build CURL!!" && popd >& /dev/null && checked_done 1
    else
        echo" ERROR: Could NOT successfully build CURL!!"
        popd >& /dev/null
        checked_done 1
    fi

    popd >& /dev/null
    popd >& /dev/null

    write_curl_env
    write_curl_install_log
    checked_done 0
}

write_curl_env() {
    ((show_summary_latch++))
    echo "export CURL_HOME=${curl_install_dir}" >> ${envfile}
    dedup ${envfile} && source ${envfile}
    return 0
}

write_curl_install_log() {
    echo "$(date ${date_format}) curl=${curl_version} ${curl_install_dir}" >> ${install_logfile}
    dedup ${install_logfile}
    return 0
}

#####
# GIT
#####
setup_git() {

    echo -n "Checking for git ${git_version}"
    check_version git ${git_version}
    [ $? == 0 ] && (( ! force_install )) && echo " [OK]" && return 0
    
    echo
    echo "*******************************"
    echo "Setting up GIT (dvcs) ${git_version}"
    echo "*******************************"
    echo

    local default="Y"
    ((force_install)) && default="N"
    local dosetup
    if [ -x ${git_install_dir}/bin/git ]; then 
        echo "Detected an existing GIT installation..."
        read -p "Do you want to continue with GIT installation and setup? $([ "$default" = "N" ] && echo "[y/N]" || echo "[Y/n]") " dosetup
        [ -z ${dosetup} ] && dosetup=${default}
        if [ "${dosetup}" != "Y" ] && [ "${dosetup}" != "y" ]; then
            echo "Skipping GIT installation and setup - will assume GIT is setup properly"
            return 0
        fi
        echo
    fi

    mkdir -p ${git_workdir}
    [ $? != 0 ] && checked_done 1
    chmod a+rw ${git_workdir}
    pushd ${git_workdir} >& /dev/null

    local git_dist_file=${git_dist_url##*/}
    #strip off .tar.gz at the end, i.e. last 7 chars, to get untarred dir name
    local git_dist_dir=$(echo ${git_dist_file} | awk 'gsub(/('$compress_extensions')/,"")')
    
    #There is this pesky case of having a zero sized dist file... WTF!?
    if [ -e ${git_dist_file} ]; then
        ls -l ${git_dist_file}
        local size=$(stat -c%s ${git_dist_file})
        (( size == 0 )) && rm -v ${git_dist_file}
    fi

    #Check to see if we have git distribution directory
    if [ ! -e ${git_dist_dir} ]; then
        echo "Don't see GIT distribution dir ${git_dist_dir}"
        if [ ! -e ${git_dist_file} ]; then
            echo "Don't see GIT distribution file ${git_dist_file} either"
            echo "Downloading GIT from ${git_dist_url}"
            wget -O ${git_dist_file} ${git_dist_url}
            [ $? != 0 ] && echo " ERROR: Could not download GIT:${git_dist_file}" && popd && checked_done 1
            echo "unpacking ${git_dist_file}..."
            tar xzf ${git_dist_file}
            [ $? != 0 ] && echo " ERROR: Could not extract GIT: ${git_dist_file}" && popd && checked_done 1
        fi
    fi

    #If you don't see the directory but see the tar.gz distribution
    #then expand it and go from there....
    if [ -e ${git_dist_file} ] && [ ! -e ${git_dist_dir} ]; then
        echo "unpacking ${git_dist_file}..."
        tar xzf ${git_dist_file}
    fi

    pushd ${git_dist_dir}
    echo "./configure --prefix=${git_install_dir}"
    if ./configure --prefix=${git_install_dir} \
        && gmake all \
        && gmake install 
    then
        echo "Successfully Configured and Built GIT in: ${git_install_dir}"
        #this is the "test"
        ${git_install_dir}/bin/git --version
        [ $? != 0 ] &&  echo" ERROR: Could NOT successfully build GIT!!" && popd >& /dev/null && checked_done 1
    else
        echo" ERROR: Could NOT successfully build GIT!!"
        popd >& /dev/null
        checked_done 1
    fi

    popd >& /dev/null
    popd >& /dev/null

    write_git_env
    write_git_install_log
    checked_done 0
}

write_git_env() {
    ((show_summary_latch++))
    echo "export GIT_HOME=${git_install_dir}" >> ${envfile}
    dedup ${envfile} && source ${envfile}
    return 0
}

write_git_install_log() {
    echo "$(date ${date_format}) git=${git_version} ${git_install_dir}" >> ${install_logfile}
    dedup ${install_logfile}
    return 0
}

#####
# Java
#####
setup_java() {

    echo -n "Checking for java ${java_version} and valid JAVA_HOME... "
    [ -e ${java_install_dir} ] && check_version $java_install_dir/bin/java ${java_version}
    [ $? == 0 ] && (( ! force_install )) && echo " [OK]" && return 0

    echo
    echo "*******************************"
    echo "Setting up Java... ${java_version}"
    echo "*******************************"
    echo

    local last_java_truststore_file

    local default="Y"
    ((force_install)) && default="N"
    local dosetup
    if [ -x ${java_install_dir}/bin/java ]; then 
        echo "Detected an existing java installation..."
        read -p "Do you want to continue with Java installation and setup? $([ "$default" = "N" ] && echo "[y/N]" || echo "[Y/n]") " dosetup
        [ -z ${dosetup} ] && dosetup=${default}
        if [ "${dosetup}" != "Y" ] && [ "${dosetup}" != "y" ]; then
            echo "Skipping Java installation and setup - will assume Java is setup properly"
            return 0
        fi
        last_java_truststore_file=$(readlink -f ${truststore_file}) 
        echo
    fi

    mkdir -p ${workdir}
    [ $? != 0 ] && checked_done 1
    pushd ${workdir} #>& /dev/null
    
    local java_dist_file=${java_dist_url##*/}
    #strip off -(32|64).tar.gz at the end
    java_dist_dir=$(echo ${java_dist_file} | awk 'gsub(/-(32|64)('$compress_extensions')/,"")')

    #Check to see if we have an Java distribution directory
    if [ ! -e ${java_install_dir%/*}/${java_dist_dir} ]; then
        echo "Don't see java distribution dir ${java_install_dir%/*}/${java_dist_dir}"
        if [ ! -e ${java_dist_file} ]; then
            echo "Don't see java distribution file $(pwd)/${java_dist_file} either"
            echo "Downloading Java from ${java_dist_url}"
            checked_get ${java_dist_file} ${java_dist_url}
            [ $? != 0 ] && echo " ERROR: Could not download Java" && popd && checked_done 1
            echo "unpacking ${java_dist_file}..."
            tar xzf ${java_dist_file} -C ${java_install_dir%/*} # i.e. /usr/local
            [ $? != 0 ] && echo " ERROR: Could not extract Java" && popd && checked_done 1
        fi
    fi

    #If you don't see the directory but see the tar.gz distribution
    #then expand it
    if [ -e ${java_dist_file} ] && [ ! -e ${java_install_dir%/*}/${java_dist_dir} ]; then
        echo "unpacking ${java_dist_file}..."
        tar xzf ${java_dist_file} -C ${java_install_dir%/*} # i.e. /usr/local
        [ $? != 0 ] && echo " ERROR: Could not extract Java..." && popd && checked_done 1
    fi

    if [ ! -e ${java_install_dir} ]; then
        ln -s ${java_install_dir%/*}/${java_dist_dir} ${java_install_dir}
        [ $? != 0 ] && \
            echo " ERROR: Could not create sym link ${java_install_dir%/*}/${java_dist_dir} -> ${java_install_dir}" && popd && checked_done 1
    else
        unlink ${java_install_dir} 
        [ $? != 0 ] && mv ${java_install_dir} ${java_install_dir}.$(date ${date_format}).bak
        
        ln -s ${java_install_dir%/*}/${java_dist_dir} ${java_install_dir}
        [ $? != 0 ] && \
            echo " ERROR*: Could not create sym link ${java_install_dir%/*}/${java_dist_dir} -> ${java_install_dir}" && popd && checked_done 1
    fi
    (($DEBUG)) && echo "chown -R ${installer_uid}:${installer_gid} ${java_install_dir}"
    chown    ${installer_uid}:${installer_gid} ${java_install_dir}
    chown -R ${installer_uid}:${installer_gid} $(readlink -f ${java_install_dir})

    popd >& /dev/null

    ${java_install_dir}/bin/java -version
    [ $? != 0 ] && echo "ERROR cannot run ${java_install_dir}/bin/java" && checked_done 1
    write_java_env
    write_java_install_log

    #-----------------------------
    #In the situation where this function is called under update
    #semantics i.e. there is already a previous installation of java
    #an installation of tomcat with tomcat setup with a properly
    #generated/configured jssecacerts file and there is a valid
    #ESG_GATEWAY_SVC_ROOT being pointed to.  We should copy over that
    #jssecacerts into this newly installed VM to satisfy SSL.
    if [ -e "${last_java_truststore_file}" ]; then
        cp -v ${last_java_truststore_file} ${java_install_dir}/conf
        chmod 644 ${java_install_dir}/conf/${last_java_truststore_file##*/}
    fi
    #-----------------------------

    checked_done 0
}

write_java_env() {
    ((show_summary_latch++))
    echo "export JAVA_HOME=${java_install_dir}" >> ${envfile}
    dedup ${envfile} && source ${envfile}
    return 0
}

write_java_install_log() {
    echo "$(date ${date_format}) java=${java_version} ${java_install_dir%/*}/${java_dist_dir}" >> ${install_logfile}
    dedup ${install_logfile}
    return 0
}


#####
# Ant
#####
setup_ant() {

    echo -n "Checking for ant ${ant_version}"
    [ -e ${ant_install_dir} ] &&  check_version ${ant_install_dir}/bin/ant ${ant_version}
    [ $? == 0 ] && (( ! force_install )) && echo " [OK]" && return 0

    echo
    echo "*******************************"
    echo "Setting up Ant... ${ant_version}"
    echo "*******************************"
    echo

    local default="Y"
    ((force_install)) && default="N"
    local dosetup
    if [ -x ${ant_install_dir}/bin/ant ]; then 
        echo "Detected an existing ant installation..."
        read -p "Do you want to continue with Ant installation and setup? $([ "$default" = "N" ] && echo "[y/N]" || echo "[Y/n]") " dosetup
        [ -z ${dosetup} ] && dosetup=${default}
        if [ "${dosetup}" != "Y" ] && [ "${dosetup}" != "y" ]; then
            echo "Skipping Ant installation and setup - will assume ant is setup properly"
            return 0
        fi
        echo
    fi

    mkdir -p ${workdir}
    [ $? != 0 ] && checked_done 1
    pushd ${workdir} >& /dev/null
    
    local ant_dist_file=${ant_dist_url##*/}
    #strip off -bin.tar.gz at the end
    ant_dist_dir=${ant_dist_file/-bin.tar.gz}

    #There is this pesky case of having a zero sized dist file... WTF!?
    if [ -e ${ant_dist_file} ]; then
        ls -l ${ant_dist_file}
        local size=$(stat -c%s ${ant_dist_file})
        (( size == 0 )) && rm -v ${ant_dist_file}
    fi

    #Check to see if we have an Ant distribution directory
    if [ ! -e ${ant_install_dir%/*}/${ant_dist_dir} ]; then
        echo "Don't see ant distribution dir ${ant_install_dir%/*}/${ant_dist_dir}"
        if [ ! -e ${ant_dist_file} ]; then
            echo "Don't see ant distribution file $(pwd)/${ant_dist_file} either"
            echo "Downloading Ant from ${ant_dist_url}"
            wget -O ${ant_dist_file} ${ant_dist_url}
            [ $? != 0 ] && echo " ERROR: Could not download Ant" && popd && checked_done 1
            echo "unpacking ${ant_dist_file}..."
            tar xzf ${ant_dist_file} -C ${ant_install_dir%/*} # i.e. /usr/local
            [ $? != 0 ] && echo " ERROR: Could not extract Ant" && popd && checked_done 1
        fi
    fi

    #If you don't see the directory but see the tar.gz distribution
    #then expand it
    if [ -e ${ant_dist_file} ] && [ ! -e ${ant_install_dir%/*}/${ant_dist_dir} ]; then
        echo "unpacking ${ant_dist_file}..."
        tar xzf ${ant_dist_file} -C ${ant_install_dir%/*} # i.e. /usr/local
        [ $? != 0 ] && echo " ERROR: Could not extract Ant..." && popd && checked_done 1
    fi

    if [ ! -e ${ant_install_dir} ]; then
        ln -s ${ant_install_dir%/*}/${ant_dist_dir} ${ant_install_dir}
        [ $? != 0 ] && \
            echo " ERROR: Could not create sym link ${ant_install_dir%/*}/${ant_dist_dir} -> ${ant_install_dir}" && popd && checked_done 1
    else
        unlink ${ant_install_dir} 
        [ $? != 0 ] && mv ${ant_install_dir} ${ant_install_dir}.$(date ${date_format}).bak

        ln -s ${ant_install_dir%/*}/${ant_dist_dir} ${ant_install_dir}
        [ $? != 0 ] && \
            echo " ERROR: Could not create sym link ${ant_install_dir%/*}/${ant_dist_dir} -> ${ant_install_dir}" && popd && checked_done 1
    fi

    ${ant_install_dir}/bin/ant -version
    [ $? != 0 ] && echo "ERROR cannot run ${ant_install_dir}/bin/ant" && checked_done 1
    write_ant_env
    write_ant_install_log
    checked_done 0

}

write_ant_env() {
    ((show_summary_latch++))
    echo "export ANT_HOME=${ant_install_dir}" >> ${envfile}
    dedup ${envfile} && source ${envfile}
    return 0
}

write_ant_install_log() {
    echo "$(date ${date_format}) ant=${ant_version} $(readlink -f ${ant_install_dir})" >> ${install_logfile}
    dedup ${install_logfile}
    return 0
}

#####
# PostgreSQL
#####
setup_postgress() {

    echo -n "Checking for postgresql ${postgress_version}"
    check_version psql ${postgress_version}
    local ret=$?
    (($ret == 0)) && (( ! force_install )) && echo " [OK]" && return 0

    
    local upgrade=$(( (ret==1) ? 1 : 0 )) #see check_version() function comments for meaning of return values

    echo
    echo "*******************************"
    echo "Setting up PostgreSQL... ${postgress_version}"
    echo "*******************************"
    echo

    local default="Y"
    ((force_install)) && default="N"
    local dosetup
    if [ -x ${postgress_install_dir}/bin/psql ]; then 
        echo "Detected an existing postgress installation..."
        read -p "Do you want to continue with Postgres installation and setup? $([ "$default" = "N" ] && echo "[y/N]" || echo "[Y/n]") " dosetup
        [ -z ${dosetup} ] && dosetup=${default}
        if [ "${dosetup}" != "Y" ] && [ "${dosetup}" != "y" ]; then
            echo "Skipping postgres installation and setup - will assume postgres is setup properly"
            return 0
        fi
        echo
    fi

    mkdir -p ${postgress_workdir}
    [ $? != 0 ] && checked_done 1
    chmod a+rw ${postgress_workdir}
    pushd ${postgress_workdir} >& /dev/null

    local postgress_dist_file=${postgress_dist_url##*/}
    #strip off .tar.gz at the end
    postgress_dist_dir=$(echo ${postgress_dist_file} | awk 'gsub(/('$compress_extensions')/,"")')
    
    #There is this pesky case of having a zero sized dist file... WTF!?
    if [ -e ${postgress_dist_file} ]; then
        ls -l ${postgress_dist_file}
        local size=$(stat -c%s ${postgress_dist_file})
        (( size == 0 )) && rm -v ${postgress_dist_file}
    fi

    #Check to see if we have postgres distribution directory
    if [ ! -e ${postgress_dist_dir} ]; then
        echo "Don't see postgress distribution dir ${postgress_dist_dir}"
        if [ ! -e ${postgress_dist_file} ]; then
            echo "Don't see postgress distribution file ${postgress_dist_file} either"
            echo "Downloading Postgress from ${postgress_dist_url}"
            wget -O ${postgress_dist_file} ${postgress_dist_url}
            [ $? != 0 ] && echo " ERROR: Could not download Postgress:${postgress_dist_file}" && popd && checked_done 1
            echo "unpacking ${postgress_dist_file}..."
            tar xzf ${postgress_dist_file}
            [ $? != 0 ] && echo " ERROR: Could not extract Postgress: ${postgress_dist_file}" && popd && checked_done 1
        fi
    fi

    #If you don't see the directory but see the tar.gz distribution
    #then expand it and go from there....
    if [ -e ${postgress_dist_file} ] && [ ! -e ${postgress_dist_dir} ]; then
        echo "unpacking ${postgress_dist_file}..."
        tar xzf ${postgress_dist_file}
    fi

    pushd ${postgress_dist_dir}
    echo "./configure --prefix=${postgress_install_dir} --enable-thread-safety"
    if ./configure --prefix=${postgress_install_dir} --enable-thread-safety \
        && gmake \
        && gmake install \
        && cd contrib/tablefunc/ \
        && gmake \
        && gmake install
    then
        echo "Successfully Configured and Built PostgresSQL in: ${postgress_install_dir}"
    else
        echo" ERROR: Could NOT successfully build POSTGRESS!"
        popd >& /dev/null
        checked_done 1
    fi

    popd >& /dev/null

    if ((upgrade)); then 
        echo "UPGRADE of postgress to ${postgress_version} completed"
        echo "It is recommended to restart the entire node as to not leave"
        echo "orphaned db connections that have been created by the rest of"
        echo "the application stack"

        echo "Restarting Database..."
        stop_postgress
        start_postgress
        checked_done $?
    fi

    ########
    #Create the system account for postgress to run as.
    ########
    id $pg_sys_acct
    if [ $? != 0 ]; then
        echo " Hmmm...: There is no postgres system account user \"$pg_sys_acct\" present on system, making one..."
        #NOTE: "useradd/groupadd" are a RedHat/CentOS thing... to make this cross distro compatible clean this up.
        /usr/sbin/groupadd -r -f ${pg_sys_acct_group}
        [ $? != 0 ] && [ $? != 9 ] && echo "ERROR: Could not add postgres system group: ${pg_sys_acct_group}" && popd && checked_done 1
        
        #set the password for the system user...
        while [ 1 ]; do 
            local input
            read -s -p "Create password for postgress system account: " input
            [ -n "${input}" ] && pg_sys_acct_passwd=${input}  && unset input && break
        done
        echo "Creating account..."
        /usr/sbin/useradd -r -c"PostgreSQL Service" -g $pg_sys_acct_group -p $pg_sys_acct_passwd -s /bin/bash $pg_sys_acct
        [ $? != 0 ] && [ $? != 9 ] && echo "ERROR: Could not add postgres system account user" && popd && checked_done 1
        echo "${pg_sys_acct_passwd}" > ${pg_secret_file}
        chmod 600 ${pg_secret_file}
        chown ${installer_uid}:${installer_gid} ${pg_secret_file}
    fi

    ########
    sleep 3
    #double check that the account is really there!
    echo
    id $pg_sys_acct >& /dev/null
    [ $? != 0 ] && grep $pg_sys_acct /etc/passwd && echo " ERROR: Problem with $pg_sys_acct creation!!!" && checked_done 1

    chown -R $pg_sys_acct $postgress_install_dir
    chgrp -R $pg_sys_acct_group $postgress_install_dir
    

    #Create the database:
    mkdir -p ${postgress_install_dir}/data
    chown -R ${pg_sys_acct} ${postgress_install_dir}/data
    [ $? != 0 ] && " ERROR: Could not change ownership of postgres' data to \"$pg_sys_acct\" user" && popd && checked_done 1

    chmod 700 $postgress_install_dir/data
    su $pg_sys_acct -c "$postgress_install_dir/bin/initdb -D $postgress_install_dir/data"
    mkdir $postgress_install_dir/log
    chown -R $pg_sys_acct $postgress_install_dir/log
    [ $? != 0 ] && " ERROR: Could not change ownership of postress' log to \"$pg_sys_acct\" user" && popd && checked_done 1


    #Start the database 
    start_postgress

    echo "$postgress_install_dir/bin/createuser -U $pg_sys_acct -P -s -e $postgress_user"
    $postgress_install_dir/bin/createuser -U $pg_sys_acct -P -s -e $postgress_user
    [ $? != 0 ] && echo " ERROR: Unable to create user on the system" && popd && checked_done 1

    #stop_postgress && return 1 #See trap in 'main'... that is who calls this.
    
    local fetch_file

    cd $postgress_install_dir/data
    #Get files
    fetch_file=pg_hba.conf
    checked_get ./${fetch_file} ${esg_dist_url}/externals/bootstrap/${fetch_file}
    (( $? > 1 )) && popd && checked_done 1
    chmod 600 ${fetch_file}


    #Get File...
    fetch_file=postgresql.conf
    checked_get ./${fetch_file} ${esg_dist_url}/externals/bootstrap/${fetch_file}
    (( $? > 1 )) && popd && checked_done 1
    chmod 600 ${fetch_file}

    #-----
    #NOTE: This database is an internal database to this esg
    #application stack... I don't think it would even be prudent to
    #offer then opportunity for someone to bind to the public
    #interface.  If they choose to do so after the fact, then they are
    #making that conscious decision, but I won't make it a part of
    #this process.

    #@@postgress_host@@ #Token in file...

    #local input
    #read -p "Please Enter the IP address or name of this host [${postgress_host}]:> " input
    #[ ! -z "${input}" ] && postgress_host=${input}
    #printf "\nUsing IP: ${postgress_host}\n"
    #eval "perl -p -i -e 's/\\@\\@postgress_host\\@\\@/${postgress_host}/g' ${fetch_file}"    
    #-----

    #@@postgress_port@@ #Token in file...

    unset input
    read -p "Please Enter PostgreSQL port number [${postgress_port}]:> " input
    [ ! -z "${input}" ] && postgress_port=${input}
    printf "\nSetting Postgress Port: ${postgress_port} "
    eval "perl -p -i -e 's/\\@\\@postgress_port\\@\\@/${postgress_port}/g' ${fetch_file}"    
    [ $? == 0 ] && printf "[OK]\n" || printf "[FAIL]\n"

    printf "Setting Postgress Log Dir: ${postgress_install_dir} "
    eval "perl -p -i -e 's#\\@\\@postgress_install_dir\\@\\@#${postgress_install_dir}#g' ${fetch_file}"    
    [ $? == 0 ] && printf "[OK]\n" || printf "[FAIL]\n"

    chown -R $pg_sys_acct $postgress_install_dir
    chgrp -R $pg_sys_acct_group $postgress_install_dir
    
    popd >& /dev/null
    echo
    check_shmmax
    echo
    write_postgress_env
    write_postgress_install_log
    checked_done 0
}

write_postgress_env() {
    ((show_summary_latch++))
    echo "export PGHOME=$PGHOME" >> ${envfile}
    echo "export PGUSER=$PGUSER" >> ${envfile}
    echo "export PGHOST=$PGHOST" >> ${envfile}
    echo "export PGPORT=$PGPORT" >> ${envfile}
    dedup ${envfile} && source ${envfile}
    return 0
}

write_postgress_install_log() {
    echo "$(date ${date_format}) postgres=${postgress_version} ${postgress_install_dir}" >> ${install_logfile}
    dedup ${install_logfile}
    return 0
}

#returns 1 if it is already running (if check_postgress_process returns 0 - true)
start_postgress() {
    check_postgress_process && return 1
    
    echo "Starting Postgress..."
    echo "su $pg_sys_acct -c \"$postgress_install_dir/bin/pg_ctl -D $postgress_install_dir/data start\""
    su $pg_sys_acct -c "$postgress_install_dir/bin/pg_ctl -D $postgress_install_dir/data start"
    [ $? != 0 ] && echo " ERROR: Could not start database!" && popd && return 1

    #NOTE: How long does it take for the database to come up? Set sleep appropriately
    echo -n "Giving database time to startup... 3 seconds " 
    sleep 3
    /bin/ps -elf | grep postgres | grep -v grep
    checked_done 0
}

stop_postgress() {
    sleep 1
    #Stop the database
    #su postgres -c "pg_ctl -D /usr/local/pgsql/data stop" #(gently stop server) 
    #

    check_postgress_process 
    [ $? != 0 ] && return 1    

    echo 
    echo "stop postgress: su $pg_sys_acct -c \"pg_ctl -D $postgress_install_dir/data -m i stop\""
    su $pg_sys_acct -c "pg_ctl -D $postgress_install_dir/data -m i stop" #(stop server immediately)
    if [ $? != 0 ]; then
        echo " WARNING: Unable to stop the database (nicely)" 
        echo " Hmmm...  okay no more mr nice guy... issuing \"killall postgres\""
        killall postgres
        [ $? != 0 ] && echo "Hmmm... still could not shutdown... do so manually"
    fi
    /bin/ps -elf | grep postgres | grep -v grep
    return 0
}

test_postgress() {
    echo
    echo "----------------------------"
    echo "Postgress Test...  "
    echo "----------------------------"
    echo 
    start_postgress

    ${postgress_install_dir}/bin/psql --version
    [ $? != 0 ] && echo" ERROR: Could NOT successfully locate postgres installation!!" && popd >& /dev/null && checked_done 1

    local ret=$(PGPASSWORD=${PGPASSWORD:-${pg_sys_acct_passwd}} psql -qt -c "select table_name from information_schema.tables;" postgres ${postgress_user} | grep -v ^$ | wc -l)
    ((ret == 0)) && echo " ERROR: Could not verify database installation! (perhaps \"pg_sys_acct_passwd\"  was not set correctly?)" && checked_done 1
    echo "[OK]"
    checked_done 0
}

#####
# Python/CDMS
#####
setup_cdat() {
    echo -n "Checking for CDAT (Pythong+CDMS) ${cdat_version}"
    check_version_with "cdat" ${cdat_version} "${cdat_home}/bin/cdatversion"
    local ret=$?
    ((ret == 0)) && (( ! force_install )) && echo " [OK]" && return 0

    echo
    echo "*******************************"
    echo "Setting up CDAT - (Python + CDMS)... ${cdat_version}"
    echo "*******************************"
    echo

    local dosetup
    if [ -x ${cdat_home}/bin/cdat ]; then 
        echo "Detected an existing CDAT installation..."
        read -p "Do you want to continue with CDAT installation and setup? [y/N] " dosetup
        if [ "${dosetup}" != "Y" ] && [ "${dosetup}" != "y" ]; then
            echo "Skipping CDAT installation and setup - will assume CDAT is setup properly"
            return 0
        fi
        echo
    fi

    mkdir -p ${workdir}
    [ $? != 0 ] && checked_done 1
    pushd ${workdir} >& /dev/null
    if [ ! -d ${workdir}/cdat ]; then
        echo "Fetching the cdat project from GIT Repo..."
        git clone ${cdat_repo}
        [ $? != 0 ] && \
            echo "Could not fetch from GIT repo using git protocol... trying http protocol..." && \
            git clone ${cdat_repo_http}
        [ $? != 0 ] && echo "Could not fetch from cdat's repo" && checked_done 1
    fi
    cd cdat >& /dev/null
    git checkout ${cdat_version}
    [ $? != 0 ] && echo " WARNING: Problem with checking out cdat revision [${cdat_version}] from repository :-("

    echo "cleaning things out" 
    ./clean_script

    #NOTE: 
    #cdms configuration with --enable-esg flag looks for pg_config in
    #$postgress_install_dir/bin.  This location is created and added
    #to the executable PATH by the 'setup_postgress' function.
    
    echo "./configure --prefix=$cdat_home --enable-esg"
    ./configure --prefix=${cdat_home} --enable-esg   
    [ $? != 0 ] && echo " ERROR: Configure did not complete successfully" && popd && checked_done 1
    make
    [ $? != 0 ] && echo " ERROR: Could not compile (make) cdat code" && popd && checked_done 1

    ${cdat_home}/bin/python -c "import cdms2" 2>/dev/null
    [ $? != 0 ] && echo " ERROR: Could not load CDMS (cdms2) module" && popd && checked_done 1

    popd >& /dev/null    
    echo
    write_cdat_env
    write_cdat_install_log
    checked_done 0
}

write_cdat_env() {
    ((show_summary_latch++))
    echo "export CDAT_HOME=${cdat_home}" >> ${envfile}
    dedup ${envfile} && source ${envfile}
    return 0
}

write_cdat_install_log() {
    echo "$(date ${date_format}) cdat=${cdat_version} ${cdat_home}" >> ${install_logfile}
    
    #Parse the cdat installation config.log file and entries to the install log
    if [ -e ${workdir}/cdat/config.log ]; then
        awk '/building/ {print "'"$(date ${date_format})"' cdat->"$(NF-1)":"$2"="$NF" '"${cdat_home}"'"}' ${workdir}/cdat/config.log >> ${install_logfile}
    else
        echo " WARNING: Could not find cdat config.log file [${workdir}/cdat/config.log] installation log entries could not be generated!"
    fi
    
    dedup ${install_logfile}
    return 0
}


#####
# ESGCET Package
#####
setup_esgcet() {

    echo -n "Checking for esgcet (the publisher) ${esgcet_version}"
    check_module_version esgcet ${esgcet_version}
    local ret=$?
    ((ret == 0)) && (( ! force_install )) && echo " [OK]" && return 0
    
    local upgrade=${1:-${ret}}

    local mode="I"
    ( ((upgrade < 2)) && (( ! force_install )) ) && mode="U" || mode="I"
    
    echo
    echo "*******************************"
    echo "Setting up ESGCET Package...(${esgcet_egg_file}) [${mode}]"
    echo "*******************************"
    echo
    
    local default="Y"
    ((force_install)) && default="N"
    local dosetup
    if [ -e ${HOME}/.esgcet/esg.ini ]; then 
        echo "Detected an existing esgcet installation..."
        read -p "Do you want to continue with esgcet installation and setup? $([ "$default" = "N" ] && echo "[y/N]" || echo "[Y/n]") " dosetup
        [ -z ${dosetup} ] && dosetup=${default}
        if [ "${dosetup}" != "Y" ] && [ "${dosetup}" != "y" ]; then
            echo "Skipping esgcet installation and setup - will assume esgcet is setup properly"
            return 0
        fi
        echo
    fi

    mkdir -p ${workdir}
    [ $? != 0 ] && return 1
    pushd ${workdir} >& /dev/null
    
    #Gives you 30 seconds to make a choice or will choose "I" by default
    local choice
    while [ 1 ]; do
        read -t $((1*60)) -p "Is this an install or update of the esgcet module? $([ "${mode}" = "I" ] && echo "[I/u]" || echo "[i/U]"): " choice
        [ -z "${choice}" ] && choice=$(echo "${mode}" | tr [a-z] [A-Z])
        if [ "${choice}" = "i" ] || [ "${choice}" = "I" ]; then
            #echo "$cdat_home/bin/easy_install -f ${esg_dist_url}/externals esgcet"
            #$cdat_home/bin/easy_install -f ${esg_dist_url}/externals esgcet
            checked_get ${esg_dist_url}/externals/${esgcet_egg_file}
            (( $? > 1 )) && return 0
            $cdat_home/bin/easy_install ${esgcet_egg_file}
            [ $? != 0 ] && checked_done 1
        elif [ "${choice}" = "u" ] || [ "${choice}" = "U" ]; then
            #echo "$cdat_home/bin/easy_install --upgrade -f ${esg_dist_url}/externals esgcet"
            #$cdat_home/bin/easy_install --upgrade -f ${esg_dist_url}/externals esgcet
            checked_get ${esg_dist_url}/externals/${esgcet_egg_file}
            (( $? > 1 )) && return 0
            $cdat_home/bin/easy_install --upgrade ${esgcet_egg_file}
            [ $? != 0 ] && checked_done 1
        else
            echo "Not a valid selection... [${choice}] try again"
            continue
        fi
        break
    done

    if [ "${mode}" = "I" ]; then
        local input=""
        read -p "What is your organization's id? [${esg_root_id}]: " input
        [ ! -z "${input}" ] && esg_root_id=${input}
        
        echo "$cdat_home/bin/esgsetup --config --rootid ${esg_root_id}" 
        $cdat_home/bin/esgsetup --config --rootid ${esg_root_id}
        [ $? != 0 ] && popd && checked_done 1
    fi

    echo "chown -R ${installer_uid}:${installer_gid} $HOME/.esgcet"
    chown -R ${installer_uid}:${installer_gid} $HOME/.esgcet 
    [ $? != 0 ] && echo "**WARNING**: Could not change owner successfully - this will lead to inability to use the publisher properly!"
    chgrp ${tomcat_group} ${HOME}/.esgcet/esg.ini && chmod 640 ${HOME}/.esgcet/esg.ini && chmod 755 ${HOME}
    [ $? != 0 ] && echo "**WARNING**: Could not change owner successfully - this will lead to inability to use the publisher properly!"
    start_postgress

    echo "$cdat_home/bin/esgsetup --db"
    $cdat_home/bin/esgsetup --db
    [ $? != 0 ] && popd && checked_done 1

    popd >& /dev/null
    echo
    echo
    if [ "${mode}" = "I" ]; then
        write_esgcet_env
    fi
    checked_done 0
}

write_esgcet_env() {
    echo "export ESG_ROOT_ID=$esg_root_id" >> ${envfile}
    dedup ${envfile} && source ${envfile}
    return 0
}

write_esgcet_install_log() {
    echo "$(date ${date_format}) python:esgcet=${esgcet_version}" >> ${install_logfile}
    dedup ${install_logfile}
    return 0
}


test_esgcet() {
    echo
    echo "----------------------------"
    echo "ESGCET Test... "
    echo "----------------------------"
    echo
    pushd $workdir >& /dev/null

    start_postgress

    #esgcet_testdir=$(readlink -f ${thredds_root_dir})/test
    esgcet_testdir=${thredds_root_dir}/test
    mkdir -p ${esgcet_testdir}
    [ $? != 0 ] && checked_done 1
    mkdir -p ${thredds_replica_dir}
    [ $? != 0 ] && checked_done 1

    echo "esgcet test directory: [${esgcet_testdir}]"
    local fetch_file
    fetch_file=sftlf.nc
    checked_get ${esgcet_testdir}/${fetch_file} ${esg_dist_url}/externals/${fetch_file}
    (( $? > 1 )) && echo " ERROR: Problem pulling down ${fetch_file} from esg distribution" && popd && checked_done 1


    #Run test...
    echo "$cdat_home/bin/esginitialize -c "
    $cdat_home/bin/esginitialize -c 
    echo "$cdat_home/bin/esgscan_directory --dataset pcmdi.${esg_root_id}.test.mytest --project test ${esgcet_testdir} > mytest.txt"
    $cdat_home/bin/esgscan_directory --dataset pcmdi.${esg_root_id}.test.mytest --project test ${esgcet_testdir} > mytest.txt
    [ $? != 0 ] && echo " ERROR: ESG directory scan failed" && popd && checked_done 1
    
    echo "$cdat_home/bin/esgpublish --map mytest.txt --project test --model test"
    $cdat_home/bin/esgpublish --map mytest.txt --project test --model test
    [ $? != 0 ] && echo " ERROR: ESG publish failed" && popd && checked_done 1
    

    popd >& /dev/null
    echo
    echo
    checked_done 0
}

#####
# Apache Tomcat
# arg 1 -> The password for the current keystore
#####
setup_tomcat() {
    echo -n "Checking for tomcat ${tomcat_version}"
    check_app_version ${tomcat_install_dir} ${tomcat_version}
    local ret=$?
    ((ret == 0)) && (( ! force_install )) && echo " [OK]" && return 0

    echo
    echo "*******************************"
    echo "Setting up Apache Tomcat...(v${tomcat_version})"
    echo "*******************************"
    echo 

    local upgrade=${1:-0}
    local last_install=$(readlink -f ${tomcat_install_dir})

    local default="Y"
    ((force_install)) && default="N"
    local dosetup
    if [ -x ${tomcat_install_dir}/bin/jsvc ]; then 
        echo "Detected an existing tomcat installation..."
        read -p "Do you want to continue with Tomcat installation and setup? $([ "$default" = "N" ] && echo "[y/N]" || echo "[Y/n]") " dosetup
        [ -z "${dosetup}" ] && dosetup=${default}
        if [ "${dosetup}" != "Y" ] && [ "${dosetup}" != "y" ]; then
            echo "Skipping tomcat installation and setup - will assume tomcat is setup properly"
            return 0
        fi
        echo
    fi

    mkdir -p ${workdir}
    [ $? != 0 ] && checked_done 1
    pushd ${workdir} >& /dev/null
    
    local tomcat_dist_file=${tomcat_dist_url##*/}
    #strip off .tar.gz at the end
    tomcat_dist_dir=$(echo ${tomcat_dist_file} | awk 'gsub(/('$compress_extensions')/,"")')

    #There is this pesky case of having a zero sized dist file... WTF!?                                                                            
    if [ -e ${tomcat_dist_file} ]; then
        ls -l ${tomcat_dist_file}
        local size=$(stat -c%s ${tomcat_dist_file})
        (( size == 0 )) && rm -v ${tomcat_dist_file}
    fi

    #Check to see if we have a tomcat distribution directory
    if [ ! -e ${tomcat_install_dir%/*}/${tomcat_dist_dir} ]; then
        echo "Don't see tomcat distribution dir ${tomcat_install_dir%/*}/${tomcat_dist_dir}"
        if [ ! -e ${tomcat_dist_file} ]; then
            echo "Don't see tomcat distribution file $(pwd)/${tomcat_dist_file} either"
            echo "Downloading Tomcat from ${tomcat_dist_url}"
            wget -O ${tomcat_dist_file} ${tomcat_dist_url}
            [ $? != 0 ] && echo " ERROR: Could not download Tomcat" && popd && checked_done 1
            echo "unpacking ${tomcat_dist_file}..."
            tar xzf ${tomcat_dist_file} -C ${tomcat_install_dir%/*} # i.e. /usr/local
            [ $? != 0 ] && echo " ERROR: Could not extract Tomcat" && popd && checked_done 1
        fi
    fi

    #If you don't see the directory but see the tar.gz distribution
    #then expand it
    if [ -e ${tomcat_dist_file} ] && [ ! -e ${tomcat_install_dir%/*}/${tomcat_dist_dir} ]; then
        echo "unpacking ${tomcat_dist_file}..."
        tar xzf ${tomcat_dist_file} -C ${tomcat_install_dir%/*} # i.e. /usr/local
        [ $? != 0 ] && echo " ERROR: Could not extract Tomcat..." && popd && checked_done 1
    fi

    if [ ! -e ${tomcat_install_dir} ]; then
        ln -s ${tomcat_install_dir%/*}/${tomcat_dist_dir} ${tomcat_install_dir}
        [ $? != 0 ] && \
            echo " ERROR: Could not create sym link ${tomcat_install_dir%/*}/${tomcat_dist_dir} -> ${tomcat_install_dir}" && popd && checked_done 1
    else
        unlink ${tomcat_install_dir}
        [ $? != 0 ] && mv ${tomcat_install_dir} ${tomcat_install_dir}.$(date ${date_format}).bak

        ln -s ${tomcat_install_dir%/*}/${tomcat_dist_dir} ${tomcat_install_dir}
        [ $? != 0 ] && \
            echo " ERROR: Could not create sym link ${tomcat_install_dir%/*}/${tomcat_dist_dir} -> ${tomcat_install_dir}" && popd && checked_done 1
    fi

    #If there is no tomcat user on the system create one (double check that usradd does the right thing)
    id $tomcat_user
    if [ $? != 0 ]; then 
        echo " WARNING: There is no tomcat user \"$tomcat_user\" present on system"
        #NOTE: "useradd/groupadd" are a RedHat/CentOS thing... to make this cross distro compatible clean this up.
        /usr/sbin/groupadd -r -f ${tomcat_group}
        [ $? != 0 ] && [ $? != 9 ] && echo "ERROR: Could not add tomcat system group: ${tomcat_group}" && popd && checked_done 1
        /usr/sbin/useradd -r -c"Tomcat Server Identity" -g $tomcat_group $tomcat_user
        [ $? != 0 ] && [ $? != 9 ] && echo "ERROR: Could not add tomcat system account user \"$tomcat_user\"" && popd && checked_done 1
    fi
    

    cd $tomcat_install_dir

    #----------
    #build jsvc (if necessary)
    #----------
    echo -n "Checking for jsvc... "
    pushd ./bin >& /dev/null
    if [ -e ./jsvc ] && [ -x ./jsvc ]; then
        echo "[OK]"
    else
        echo "[NOT PRESENT]"
        echo "Building jsvc... (JAVA_HOME=$java_install_dir)"

        if [ -e commons-daemon-native.tar.gz ]; then
            echo "unpacking commons-daemon-native.tar.gz..."
            tar xzf commons-daemon-native.tar.gz
            cd commons-daemon-*-native-src/unix
            #It turns out they shipped with a conflicting .o file in there (oops) so I have to remove it manually.
            rm -f ./native/libservice.a
            make clean
        elif [ -e jsvc.tar.gz ]; then
            echo "unpacking jsvc.tar.gz..."
            tar xzf jsvc.tar.gz
            cd jsvc-src
            autoconf
        else
            echo "NOT ABLE TO INSTALL JSVC!" && checked_done 1
        fi

        chmod 755 ./configure
        ./configure --with-java=${java_install_dir}
        make
        [ -x ./jsvc ] && cp ./jsvc ${tomcat_install_dir}/bin
    fi
    popd >& /dev/null
    #----------
    
    #----------------------------------
    # Upgrade logic...
    #----------------------------------
    if ((upgrade)) ; then
        stop_tomcat
        echo "Upgrading tomcat installation from $(readlink -f ${last_install} | sed -ne 's/.*-\(.*\)$/\1/p') to $(readlink - f ${tomcat_install_dir} | sed -ne 's/.*-\(.*\)$/\1/p')"

        echo -n "copying webapps... "
        cp -R ${last_install}/webapps ${tomcat_install_dir}/
        [ $? == 0 ] && echo "[OK]" || echo "[FAIL]"

        echo -n "copying configuration... "
        cp -R ${last_install}/conf ${tomcat_install_dir}/
        [ $? == 0 ] && echo "[OK]" || echo "[FAIL]"

        echo -n "copying logs... "
        cp -R ${last_install}/logs ${tomcat_install_dir}/
        [ $? == 0 ] && echo "[OK]" || echo "[FAIL]"

        echo "upgrade migration complete"
    else
        local store_password=${1}
        configure_tomcat ${store_password}
    fi
    #----------------------------------
        
    chown -R $tomcat_user $(readlink -f ${tomcat_install_dir})
    [ $? != 0 ] && " ERROR: Could not change ownership of tomcat to \"$tomcat_user\" user" && popd && checked_done 1
    chgrp -R $tomcat_group $(readlink -f ${tomcat_install_dir})
    [ $? != 0 ] && " ERROR: Could not change group of tomcat to \"$tomcat_user\" user" && popd && checked_done 1
    
    #-------------------------------
    # For Security Reasons...
    #-------------------------------

    if [ -d ${tomcat_install_dir}/webapps/examples ]; then
        local dodel="Y"
        echo "For security reasons we recommend removing the examples web app"
        readlink -f ${tomcat_install_dir}/webapps/examples
        read -p "Is the directory shown above correct? [Y/n] " dodel
        if [ "${dodel}" = "Y" ] || [ "${dodel}" = "y" ] || [ -z "${dodel}" ]; then
            rm -rf ${tomcat_install_dir}/webapps/examples && echo "removed the examples webapp..."
        fi
    fi

    start_tomcat

    #---
    #port testing for http and https
    #---
    local ret_all=0
    local ports=$(sed -n 's/.*Connector.*port="\([0-9]*\)".*/\1/p' ${tomcat_install_dir}/conf/server.xml)
    echo "checking connection at all ports described in server.xml: "${ports}
    for port in ${ports[@]}; do
        echo -n "checking http://localhost:${port} "
        local wait_time=5
        local ret=1
        while [[ $wait_time > 0 ]]; do
            curl http://localhost:${port} >& /dev/null
            ret=$?
            [ $ret == 0 ] && break
            sleep 1
            ((wait_time--))
            echo -n "."
        done
        [ $ret == 0 ] && echo " [OK]" || echo " [FAIL]"

        #We only care about reporting a failure for ports below 1024 
        #specifically 80 (http) and 443 (https)
        (($port < 1024)) && ((ret_all+=ret))

    done
    
    [ $ret_all != 0 ] && echo "[FAILED]" && echo " ERROR: Not able to contact top level tomcat page on this server" && popd && checked_done 1
    echo "[OK]"
    #---

    echo
    popd >& /dev/null
    echo
    echo
    write_tomcat_env
    write_tomcat_install_log
    return 0
}

write_tomcat_env() {
    ((show_summary_latch++))
    echo "export CATALINA_HOME=${CATALINA_HOME}" >> ${envfile}
    dedup ${envfile} && source ${envfile}
    return 0
}

write_tomcat_install_log() {
    echo "$(date ${date_format}) tomcat=${tomcat_version} $(readlink -f ${tomcat_install_dir})" >> ${install_logfile}
    dedup ${install_logfile}
    return 0
}

configure_tomcat() {
    #----------------------------
    # TOMCAT Configuration...
    #----------------------------

    echo
    echo "*******************************"
    echo "Configuring Tomcat... (for Data Node Manager)"
    echo "*******************************"
    echo

    pushd ${tomcat_install_dir}/conf #>& /dev/null
    
    local fetch_file
    local genreq=N

    fetch_file=server.xml
    checked_get ./${fetch_file} ${esg_dist_url}/externals/bootstrap/node.${fetch_file}
    (( $? > 1 )) && popd && checked_done 1
    chmod 600 ${fetch_file}

    #Create a keystore in $tomcat_conf_dir
    echo "Keystore setup: "
    local store_password=${1}
    if [ ! -e ${keystore_file} ]; then
        echo "Launching Java's keytool:"
        
        if [ -z "${store_password}" ]; then
            local verify_password
            while [ 1 ]; do
                echo
                read -s -p "Please enter the password for this keystore   : " store_password
                [ "${store_password}" = "changeit" ] && break
                [ -z "${store_password}" ] && echo "Invalid password [${store_password}]" && continue
                echo
                read -s -p "Please re-enter the password for this keystore: " verify_password
                if [ "${store_password}" = "${verify_password}" ] ; then
                    echo
                    break
                else
                    echo "Sorry, values did not match"
                    echo
                fi
            done
            unset verify_password
            echo
        else 
            echo "store_password = ******"
        fi

        #NOTE:
        #As Reference on Distingueshed Names (DNs)
        #http://download.oracle.com/javase/1.4.2/docs/tooldocs/windows/keytool.html
        #According to that document, case does not matter but ORDER DOES!
        #See script scope declaration of this variable (dname="OU=simpleCA-pcmdi3.llnl.gov, OU=GlobusTest, O=Grid")

        if [ -z "${dname}" ]; then
            $java_install_dir/bin/keytool -genkey -alias ${keystore_alias} -keyalg RSA -keystore ${keystore_file} -validity 365 -storepass ${store_password}
            [ $? != 0 ] && echo " ERROR: keytool genkey command failed" && popd && checked_done 1
        else
            echo "${dname}" | grep -i 'cn='
            [ $? != 0 ] && dname="CN=$(hostname --fqdn), ${dname}"
            echo "Using keystore DN = ${dname}"
            $java_install_dir/bin/keytool -genkey -dname "${dname}" -alias ${keystore_alias} -keyalg RSA -keystore ${keystore_file} -validity 365 -storepass ${store_password}
            [ $? != 0 ] && echo " ERROR*: keytool genkey command failed" && popd && checked_done 1
        fi
        
        genreq="Y"
    else
        echo "Using existing keystore \"${keystore_file}\""
    fi

    local answer
    read -p "Do you wish to generate a Certificate Signing Request at this time? $([ $genreq = "Y" ] && echo "[Y/n]" || echo "[y/N]") " answer
    [ -n "${answer}" ] && genreq=${answer}
    unset answer
    echo " -> [${genreq}]"
    if [ "${genreq}" == "Y" ] || [ "${genreq}" == "y" ]; then
        echo "Generating Certificate Signing Request..."
        #-------------------------------------------------
        #Previous way, when we were generating the request directly from the keystore via keytool
        #${java_install_dir}/bin/keytool -certreq -alias ${keystore_alias} -keystore ${keystore_file} -file ${HOME}/$(hostname --fqdn)-esg-node.csr
        #[ $? != 0 ] && echo " ERROR: keytool certreq command failed"
        #-------------------------------------------------

        #Now we generate the key and cert externally, but maintaining the DN specified in the, just built, keystore
        local dn=$(extract_keystore_dn ${keystore_file} ${store_password})
        sleep 1
        generate_ssl_key_and_csr ${tomcat_conf_dir}/hostkey.pem ${tomcat_conf_dir}/$(hostname --fqdn)-esg-node.csr ${dn}
        [ $? != 0 ] && echo " ERROR: Unable to generate ssl key and csr! (you will have to run --generate-ssl-key-and-csr after installation)"

        chown -R ${installer_uid}:${installer_gid} $(hostname --fqdn)-esg-node.csr
    fi
    

    #Fetch/Copy truststore to $tomcat_conf_dir
    #(first try getting it from distribution server otherwise copy Java's)
    if [ ! -e ${truststore_file} ]; then
        fetch_file=${truststore_file##*/} # i.e. esg-truststore.ts
        checked_get ${truststore_file} ${esg_dist_url}/certs/${fetch_file}
        if (( $? > 1 )); then
            echo " INFO: Could not download certificates ${fetch_file} for tomcat - will copy local java certificate file"
            echo "(note - the truststore password will probably not match!)"
            cp -v ${java_install_dir}/jre/lib/security/cacerts ${truststore_file}
            [ $? != 0 ] && echo " ERROR: Could not fetch or copy ${fetch_file} for tomcat!!" && popd && checked_done 1
        fi
    fi

    add_my_cert_to_truststore ${store_password}


    #NOTE: The truststore uses the java default password: "changeit"

    #Edit the server.xml file to contain proper location of certificates
    eval "perl -p -i -e 's#\\@\\@tomcat_users_file\\@\\@#${tomcat_users_file}#g' server.xml"
    echo -n "*"
    eval "perl -p -i -e 's#\\@\\@truststore_file\\@\\@#${truststore_file}#g' server.xml"
    echo -n "*"
    eval "perl -p -i -e 's#\\@\\@truststore_password\\@\\@#changeit#g' server.xml"
    echo -n "*"
    eval "perl -p -i -e 's#\\@\\@keystore_file\\@\\@#${keystore_file}#g' server.xml"
    echo -n "*"
    eval "perl -p -i -e 's#\\@\\@keystore_password\\@\\@#${store_password}#g' server.xml"
    echo "*"

    #clean up the password immediately after it is done being used
    keystore_password=${store_password} #don't want to do this but it is used by the esg-security script that installs the ORP
    unset store_password

    chown -R $tomcat_user $(readlink -f ${tomcat_install_dir})
    [ $? != 0 ] && " ERROR: Could not change ownership of tomcat to \"$tomcat_user\" user" && popd && checked_done 1
    chgrp -R $tomcat_group $(readlink -f ${tomcat_install_dir})
    [ $? != 0 ] && " ERROR: Could not change group of tomcat to \"$tomcat_user\" user" && popd && checked_done 1

    chown -R $tomcat_user $(readlink -f ${tomcat_conf_dir})
    [ $? != 0 ] && " ERROR: Could not change ownership of esg's tomcat config dir to \"$tomcat_user\" user" && popd && checked_done 1
    chgrp -R $tomcat_group $(readlink -f ${tomcat_conf_dir})
    [ $? != 0 ] && " ERROR: Could not change group of esg's tomcat config dir to \"$tomcat_user\" user" && popd && checked_done 1

    popd #>& /dev/null
}


start_tomcat() {
    check_tomcat_process
    local ret=$? 
    ((ret == 0)) && return 1
    ((ret == 3)) && echo "Please resolve this issue before starting tomcat!" && checked_done $ret

    echo "Starting Tomcat (jsvc)..."
    pushd $tomcat_install_dir >& /dev/null
    [ $((sel & IDP_BIT)) != 0 ]  && java_opts+=" -XX:MaxPermSize=128m"
    jsvc_launch_command="JAVA_HOME=$java_install_dir ./bin/jsvc -Djava.awt.headless=true -Dcatalina.home=${tomcat_install_dir} -pidfile $tomcat_pid_file -cp $(find $(readlink -f `pwd`/bin/) | grep jar | xargs | perl -pe 's/ /:/g') -outfile ./logs/catalina.out -errfile ./logs/catalina.err -user $tomcat_user $tomcat_opts $java_opts -Dsun.security.ssl.allowUnsafeRenegotiation=false org.apache.catalina.startup.Bootstrap"
    echo "$jsvc_launch_command"
    JAVA_HOME=${java_install_dir} ./bin/jsvc \
        -Djava.awt.headless=true \
        -Dcatalina.home=${tomcat_install_dir} \
        -pidfile ${tomcat_pid_file} \
        -cp $(find $(readlink -f `pwd`/bin/) | grep .jar | xargs | perl -pe 's/ /:/g') \
        -outfile ./logs/catalina.out \
        -errfile ./logs/catalina.err \
        -user $tomcat_user \
        ${tomcat_opts} \
        $java_opts -Dsun.security.ssl.allowUnsafeRenegotiation=false \
        org.apache.catalina.startup.Bootstrap
    if [ $? != 0 ]; then 
        echo " ERROR: Could not start up tomcat"
        tail ./logs/catalina.err
        popd >& /dev/null
        checked_done 1
    fi
    
    #Don't wait forever, but give tomcat some time before it starts
    pcheck 5 2 1 -- check_tomcat_process
    [ $? != 0 ] && echo "Tomcat couldn't be started."

}

stop_tomcat() {
    #
    #Stop Tomcat
    #% sudo /usr/local/tomcat/bin/jsvc -pidfile /var/run/tomcat-jsvc.pid -stop org.apache.catalina.startup.Boostrap
    #

    check_tomcat_process 
    [ $? != 0 ] && return 1

    pushd $tomcat_install_dir >& /dev/null
    echo 
    echo "stop tomcat: ./bin/jsvc -pidfile $tomcat_pid_file -stop org.apache.catalina.startup.Bootstrap"
    echo "(please wait)"
    sleep 1
    ./bin/jsvc -pidfile $tomcat_pid_file -stop org.apache.catalina.startup.Bootstrap
    if [ $? != 0 ]; then
        local ret=0
        echo " WARNING: Unable to stop tomcat, (nicely)" 
        echo -n " Hmmm...  okay no more mr nice guy... issuing "
        #echo -n "\"killall jsvc\" and " && killall jsvc
        #((ret+=$?))
        echo -n "\"pkill -9 $(cat ${tomcat_pid_file})\"" && kill -9 $(cat ${tomcat_pid_file}) >& /dev/null
        ((ret+=$?))
        echo ""
        [ "$ret" != 0 ] && echo "Hmmm... still could not shutdown... process may have already been stopped"
    fi
    /bin/ps -elf | grep jsvc | grep -v grep
    popd >& /dev/null
    return 0
}

test_tomcat() {

    echo
    echo "----------------------------"
    echo "Tomcat Test...  "
    echo "----------------------------"
    echo
    start_tomcat
    
    echo "giving tomcat some time to wake up"
    sleep 5

    #check_tomcat_process 
    #[ $? != 0 ] && echo "[FAILED] process not running..." && return 0
    ports=$(sed -n 's/.*Connector.*port="\([0-9]*\)".*/\1/p' $tomcat_install_dir/conf/server.xml)
    echo "checking connection at ports "$ports
    local running_port="$(
            echo "$ports" | while read check_port; do
                echo "checking $check_port" >&2
                wget http://localhost:$check_port -O - -q >/dev/null
                if [[ $? == "0" ]]; then
                    echo $check_port
                    break
                fi
            done
            )"
    
    if [[ -n "$running_port" ]]; then
        echo "Tomcat is running on port $running_port"
        checked_done 0
    else
        echo "Tomcat is not listening to any listed port."
        checked_done 1
    fi

}

#####
# Install The Data Node Manager
#####
# - Takes boolean arg: 0 = setup / install mode (default)
#                      1 = updated mode
#
# In setup mode it is an idempotent install (default)
# In update mode it will always pull down latest after archiving old
#
setup_node() {
    echo -n "Checking for node manager ${node_version}"
    check_webapp_version "esg-node" ${node_version}
    local ret=$?
    ((ret == 0)) && (( ! force_install )) && echo " [OK]" && return 0

    echo
    echo "*******************************"
    echo "Setting up The ESG Node Manager..."
    echo "*******************************"
    echo

    local upgrade=${1:-0}

    local default="Y"
    ((force_install)) && default="N"
    local dosetup
    if [ -d ${node_app_home} ]; then 
        echo "Detected an existing node manager installation..."
        read -p "Do you want to continue with node manager installation and setup? $([ "$default" = "N" ] && echo "[y/N]" || echo "[Y/n]") " dosetup
        [ -z "${dosetup}" ] && dosetup=${default}
        if [ "${dosetup}" != "Y" ] && [ "${dosetup}" != "y" ]; then
            echo "Skipping node manager installation and setup - will assume it's setup properly"
            return 0
        fi
        
        local dobackup="Y"
        read -p "Do you want to make a back up of the existing distribution?? [Y/n] " dobackup
        [ -z "${dobackup}" ] && dobackup=${default}
        if [ "${dobackup}" = "Y" ] || [ "${dobackup}" = "y" ]; then
            echo "Creating a backup archive of this web application $node_app_home"
            backup ${node_app_home}
        fi

        echo
    fi

    mkdir -p ${workdir}
    [ $? != 0 ] && return 1
    pushd ${workdir} >& /dev/null
    local fetch_file


    local node_dist_file=${node_dist_url##*/}
    #strip off .tar.gz at the end
    #(Ex: esg-node.0.9.0.tar.gz -> esg-node.0.9.0)
    node_dist_dir=$(echo ${node_dist_file} | awk 'gsub(/('$compress_extensions')/,"")')

    checked_get ${node_dist_file} ${node_dist_url}
    no_new_update=$?

    if((upgrade)); then
        ((no_new_update == 1)) && echo "nothing more to do, you are up2date" && return 1
        echo "Upgrading the ESG Node Manager..."
        rm -rf ${node_dist_dir}
    fi
    
    echo "unpacking ${node_dist_file}..."
    tar xzf ${node_dist_file}
    [ $? != 0 ] && echo " ERROR: Could not extract the ESG Node: ${node_dist_file}" && popd && checked_done 1
    
    pushd ${node_dist_dir} >& /dev/null

    stop_tomcat

    #strip the version number off(#.#.#) the dir and append .war to get the name of war file
    #(Ex: esg-node.0.9.0 -> esg-node.war) 
    local trimmed_name=$(pwd)/${node_dist_dir%%.*}
    node_war_file=${trimmed_name}.war
    echo "node_war_file = "${node_war_file}

    mkdir -p ${node_app_home}
    cd ${node_app_home}


    #----------------------------
    fetch_file=esg-node.properties

    #NOTE: The saving of the last config file must be done *BEFORE* we untar the new distro!
    if ((upgrade)) && [ -e WEB-INF/classes/${fetch_file} ]; then
        cp WEB-INF/classes/${fetch_file} WEB-INF/classes/${fetch_file}.saved
        chmod 600 WEB-INF/classes/${fetch_file}*
    fi

    echo "Expanding war ${node_war_file} in $(pwd)"
    $JAVA_HOME/bin/jar xf ${node_war_file}
    
    
    #----------------------------
    #Property file fetching and token replacement...
    #----------------------------
    pushd WEB-INF/classes >& /dev/null

    cp ${fetch_file} ${fetch_file}.tmpl
    if((upgrade)) && [ -e ${fetch_file}.saved ]; then
        #reuse the last esg-node.properties file...
        #pull it out of the tar archive we made a few lines up
        cp ${fetch_file}.saved ${fetch_file}
    else
        #----------------------
        pwd
        echo -n "Replacing tokens... "

        eval "perl -p -i -e 's/\\@db.driver\\@/${postgress_driver}/g' ${fetch_file}"    
        echo -n "*"
        eval "perl -p -i -e 's/\\@db.protocol\\@/${postgress_protocol}/g' ${fetch_file}"
        echo -n "*"
        
        eval "perl -p -i -e 's/\\@db.host\\@/${postgress_host}/g' ${fetch_file}"    
        echo -n "*"
        eval "perl -p -i -e 's/\\@db.port\\@/${postgress_port}/g' ${fetch_file}"
        echo -n "*"
        eval "perl -p -i -e 's/\\@db.database\\@/${node_db_name}/g' ${fetch_file}"
        echo -n "*"
        eval "perl -p -i -e 's/\\@db.user\\@/${postgress_user}/g' ${fetch_file}"
        echo -n "*"
        eval "perl -p -i -e 's/\\@db.password\\@/${pg_sys_acct_passwd}/g' ${fetch_file}"
        echo -n "*"
        
        eval "perl -p -i -e 's/\\@mail.smtp.host\\@/${mail_smtp_host}/g' ${fetch_file}"
        echo -n "*"
        eval "perl -p -i -e 's/\\@mail.admin.address\\@/${mail_admin_address}/g' ${fetch_file}"
        echo -n "*"
        echo " [OK]"
        #----------------------
    fi
    chown -R ${tomcat_user} ${node_app_home}
    chgrp -R ${tomcat_group} ${node_app_home}
    unset fetch_file
    popd >& /dev/null
    #----------------------------

    popd >& /dev/null
    (( ! upgrade )) && configure_postgress
    write_node_install_log
    set_redirect
    checked_done 0

}

write_node_install_log() {
    echo "$(date ${date_format}) webapp:esg-node=${node_version} ${node_app_home}" >> ${install_logfile}
    dedup ${install_logfile}
    return 0
}

#setup the ROOT app's index.html to redirct to the esg-node's index page (BOOM!)
set_redirect() {

    local index_file=${tomcat_install_dir}/webapps/ROOT/index.html

    [ ! -e ${index_file} ] && echo "Sorry, No \"ROOT\" application found!" && return 1

    local redirect_content="<head><meta HTTP-EQUIV=\"REFRESH\" content=\"0; url=/esg-node\"></head>"

    [ "${redirect_content}" = "$(cat ${index_file})" ] && echo "Redirect already setup" && return 0

    local doit="Y"
    read -p "Do you wish to setup the redirect to the esg-node's page? [Y/n]: " doit
    [ "n" = "${doit}" ] || [ "N" = "${doit}" ] && return 0

    mv ${index_file} ${index_file}.last

    echo "${redirect_content}" > ${index_file}
    chmod 644 ${index_file}
    chown -R ${tomcat_user}  ${index_file}
    chgrp -R ${tomcat_group} ${index_file}
    echo "Redirect setup to /esg-node"
    return 0
}


#--------------------------------------------------
#NOTE: This must be run AFTER the esg node web app
#      installation/configuration (setup_node) 
#--------------------------------------------------
configure_postgress() {
    
    echo
    echo "*******************************"
    echo "Configuring Postgres... (for Data Node Manager)"
    echo "*******************************"
    echo

    start_postgress

    #Create the database...
    echo "Creating esg node database: ${node_db_name}"
    echo "${postgress_install_dir}/bin/createdb ${node_db_name}"
    ${postgress_install_dir}/bin/createdb ${node_db_name} >& /dev/null
    (( $? > 1 )) && echo " ERROR: Could not create esg node database: ${node_db_name}" && return 0
    
    #TODO... Make the above call idempotent...
    #NOTE: (zoiks) Need to be able to tell the difference between a
    #database already there vs another error

    pushd ${workdir}/${node_dist_dir:-esg-node.${node_version}}/db
    [ $? != 0 ] && echo " ERROR: Could not find node distribution dir ${workdir}/${node_dist_dir}" && checked_done 1

    echo "${ANT_HOME}/bin/ant -buildfile database-tasks.ant.xml \
        -Dnode.property.file=${node_app_home}/WEB-INF/classes/esg-node.properties \
        -Dsql.jdbc.base.url=${postgress_protocol}//${postgress_host}:${postgress_port}/ \
        -Dsql.jdbc.database.name=${node_db_name} \
        -Dsql.jdbc.database.user=${postgress_user} \
        -Dsql.jdbc.database.password=${pg_sys_acct_passwd} \
        -Dsql.jdbc.driver.jar=${node_app_home}/WEB-INF/lib/${postgress_jar} make_node_db"

    ${ANT_HOME}/bin/ant -buildfile database-tasks.ant.xml \
        -Dnode.property.file=${node_app_home}/WEB-INF/classes/esg-node.properties \
        -Dsql.jdbc.base.url=${postgress_protocol}//${postgress_host}:${postgress_port}/ \
        -Dsql.jdbc.database.name=${node_db_name} \
        -Dsql.jdbc.database.user=${postgress_user} \
        -Dsql.jdbc.database.password=${pg_sys_acct_passwd} \
        -Dsql.jdbc.driver.jar=${node_app_home}/WEB-INF/lib/${postgress_jar} make_node_db >& /dev/null
    (( $? > 1 )) && echo "ERROR: Could not create esg node database tables in ${node_db_name}" && return 1
    
    popd >& /dev/null
    echo
    echo
    checked_done 0
}

#####
# THREDDS Data Server
#####
setup_tds() {
    echo -n "Checking for thredds (tds) ${tds_version}"
    check_webapp_version "thredds" ${tds_version} "Implementation-Version"
    local ret=$?
    ((ret == 0)) && (( ! force_install )) && echo " [OK]" && return 0

    echo
    echo "*******************************"
    echo "Setting up Thredds Data Server... v${tds_version}"
    echo "*******************************"
    echo

    local dosetup
    if [ -d ${tomcat_install_dir}/webapps/thredds ]; then 
        echo "Detected an existing thredds installation..."
        read -p "Do you want to continue with thredds installation and setup? [y/N] " dosetup
        if [ "${dosetup}" != "Y" ] && [ "${dosetup}" != "y" ]; then
            echo "Skipping thredds installation and setup - will assume thredds is setup properly"
            return 0
        fi
        echo
    fi

    mkdir -p ${workdir}
    [ $? != 0 ] && return 1
    pushd ${workdir} >& /dev/null
    local fetch_file

    ############################
    #Download the thredds.war file home site (or use value of thredds_dist_file if already set)
    ############################

    thredds_dist_file=${thredds_dist_file:-${thredds_dist_url##*/}}
    
    #There is this pesky case of having a zero sized dist file... WTF!?                                                                            
    if [ -e ${thredds_dist_file} ]; then
        ls -l ${thredds_dist_file}
        local size=$(stat -c%s ${thredds_dist_file} >& /dev/null)
        (( size == 0 )) && rm -v ${thredds_dist_file}
    fi

    #Check to see if we have this war file already in the workbench...
    #if [ ! -e ${thredds_dist_file} ]; then
    #   wget -O ${thredds_dist_file} ${thredds_dist_url}
    #   if [ $? != 0 ]; then
    #       echo " ERROR: Could not download ${thredds_dist_url}, fetching the copy at PCMDI (LLNL)..."
    checked_get ${thredds_dist_file} ${thredds_esg_dist_url}
    (( $? > 1 )) && echo " ERROR: Could not download ${thredds_esg_dist_url} either" && popd && checked_done 1
    #   fi
    #fi
    
    stop_tomcat
    
    #-------------------------------------------
    #installing the thredds web app ("manually")
    cp ${thredds_dist_file} ${tomcat_install_dir}/webapps
    pushd ${tomcat_install_dir}/webapps
    mkdir thredds
    cd thredds
    jar xf ../${thredds_dist_file}
    cd ..
    chown -R ${tomcat_user}  thredds*
    chgrp -R ${tomcat_group} thredds*
    rm ${thredds_dist_file}
    popd
    #-------------------------------------------


    ############################
    #Setup Digest authentication
    ############################

    pushd ${tomcat_conf_dir} >& /dev/null

    fetch_file=tomcat-users.xml
    checked_get $tomcat_conf_dir/${fetch_file} ${esg_dist_url}/externals/bootstrap/${fetch_file}
    (( $? > 1 )) && popd && checked_done 1
    chown ${tomcat_user}  $tomcat_conf_dir/${fetch_file}
    chgrp ${tomcat_group} $tomcat_conf_dir/${fetch_file}
    

    #1: Generate password hash
    printf "Create user credentials\n"
    local input

    while [ 1 ]; do 
        #default credential values...
        local username="dnode_user"
        local password="changeme"
        unset input
        unset addanother
        read -p "Please enter username for tomcat [${username}]:  " input
        [ ! -z "${input}" ] && username=${input}    
        echo ${username}
        unset input
        read -s -t60 -p "Please enter password for user, \"${username}\" [********]:   " input
        [ ! -z "${input}" ] && password=${input}    
        password_hash=$($tomcat_install_dir/bin/digest.sh -a SHA ${password} | cut -d ":" -f 2)
        echo ${password_hash}
        
        #Create user entry in tomcat-users.xml for thredds user
        user_entry="<user username=\"${username}\" password=\"${password_hash}\" roles=\"tdrAdmin,tdsConfig\"\/>"
        #Note: Have to escape the last "/" in "/>"
        
        #Insert the entry in the right place in tomcat-users.xml
        #Replace <!--@@user_entry@@--> with ${user_entry}\n<!--@@user_entry@@-->
        #Command Line:% perl -p -i -e 's/<!--\@\@user_entry\@\@-->/<test>\n  <!--\@\@user_entry\@\@-->/g' tomcat-users.xml
        eval "perl -p -i -e 's/<!--\\@\\@user_entry\\@\\@-->/${user_entry}\n  <!--\\@\\@user_entry\\@\\@-->/g' tomcat-users.xml"
        
        read -p "Would you like to add another user? [y/N]: " addanother
        if [ "${addanother}" = "y" ] || [ "${addanother}" = "Y" ]; then
            echo 
            continue
        fi
        echo
        break
    done
    unset input

    popd >& /dev/null

    ############################
    #Enable SSL encryption
    ############################

    mkdir -p ${tomcat_conf_dir}/Catalina/localhost
    fetch_file=thredds.xml
    checked_get $tomcat_conf_dir/Catalina/localhost/${fetch_file} ${esg_dist_url}/externals/bootstrap/tomcat-${fetch_file}
    (( $? > 1 )) && echo " ERROR: Problem pulling down ${fetch_file} from esg distribution" && popd && checked_done 1

    
    #Get the templated web.xml file... (with tokens for subsequent filter entries: see [esg-]security-[token|tokenless]-filters[.xml] files)
    fetch_file=web.xml 
    checked_get ${tomcat_install_dir}/webapps/thredds/WEB-INF/${fetch_file} ${esg_dist_url}/thredds/thredds.${fetch_file}
    (( $? > 1 )) && popd && checked_done 1
    chown -R ${tomcat_user}  ${tomcat_install_dir}/webapps/thredds/WEB-INF/${fetch_file} 
    chgrp -R ${tomcat_group} ${tomcat_install_dir}/webapps/thredds/WEB-INF/${fetch_file} 

    #DEBUGGING
    (($DEBUG)) && cat ${tomcat_install_dir}/webapps/thredds/WEB-INF/${fetch_file}


    #(Making this assignment for the sake of readability for the code below)
    #@@node_host_ip_address@@ #Token in file
    node_host_ip_address=${my_ip_address}    

    #just to be sure it's clear (though it should be)
    unset input 
    read -p "Please Enter the IP address of this host [${node_host_ip_address}]:> " input
    [ ! -z "${input}" ] && node_host_ip_address=${input}
    printf "\nUsing IP: ${node_host_ip_address}\n"
    unset input

    #@@gateway_name@@ -> @@gateway_service_root@@  #Tokens in file
    #ESG-PCMDI -> pcmdi3.llnl.gov/esgcet
    #ESC-NCAR  -> esg.prototype.ucar.edu
    
    local choice
    while [ 1 ]; do
        unset choice
        printf "Please select the gateway for this node: \n"
        printf "\t-------------------------------------------\n"
        printf "\t*[1] : ESG-PCMDI -> pcmdi3.llnl.gov/esgcet\n"
        printf "\t [2] : ESG-NCAR  -> esg.ucar.edu\n"
        printf "\t-------------------------------------------\n"
        printf "\t [C] : (Manual Entry)\n"
        printf "\t-------------------------------------------\n"
        read -p "select [1] > " choice
        
        [ -z "${choice}" ] && choice=1 #default
        case ${choice} in
            2)  gateway_name="ESG-NCAR"
                gateway_service_root="esg.ucar.edu"
                ;;
            1)  gateway_name="ESG-PCMDI"
                gateway_service_root="pcmdi3.llnl.gov/esgcet"
                myproxy_port=2119 #hack till we open the right port
                ;;
            c | C)
                local input
                gateway_name=${ESG_GATEWAY_NAME:-"ESG-PCMDI"}
                gateway_service_root=${ESG_GATEWAY_SVC_ROOT:-"pcmdi3.llnl.gov/esgcet"}
                read -p "Please enter the Gateway name [${ESG_GATEWAY_NAME}] " input
                [ -n "${input}" ] && gateway_name=$input
                unset input
                read -p "Please enter the Gateway Service Root [${ESG_GATEWAY_SVC_ROOT}] " input
                [ -n "${input}" ] && gateway_service_root=$(echo ${input} | tr 'a-z' 'A-Z')
                unset input
                choice="(Manual Entry)"
                ;;
            *)  echo "Invalid selection [${choice}]"
        esac
        echo
        echo "You have selected: ${choice}"
        echo "${gateway_name} -> ${gateway_service_root}"
        echo 
        local is_correct
        read -p "Is this correct? [Y/n] " is_correct
        is_correct=$(echo ${is_correct} | tr 'A-Z' 'a-z')
        if [ "${is_correct}" = "n" ]; then
            continue
        else
            break
        fi
    done
    
    myproxy_endpoint=${gateway_service_root%%/*}

    echo
    echo "Selection: [${choice}] source: ${node_host_ip_address}   dest: ${gateway_name}:${gateway_service_root}"

    #----------------------
    #Fetch and Insert the Certificate for parent gateway
    register ${myproxy_endpoint}
    [ $? != 0 ] && echo " Error: could not import gateway certificate!" && checked_done 1
    #----------------------

    #See thredds_content_dir set in init() - default value is ${esg_root_dir}/content

    #--------
    #hack - prerequiset for esgsetup... should be done in esgsetup code :-\
    mkdir -p ${thredds_content_dir}
    chown -R ${tomcat_user}:${tomcat_group} ${thredds_content_dir}
    chmod -R 755 ${thredds_content_dir}
    #--------

    #--------
    #EDIT the thredds property file: ${tomcat_install_dir}/webapps/thredds/WEB-INF/classes/thredds/server/tds.properties
    #replace the value for token "tds..content.root.path" with ${thredds_content_dir}
    local thredds_property_file=${tomcat_install_dir}/webapps/thredds/WEB-INF/classes/thredds/server/tds.properties
    if [ -e ${thredds_property_file} ]; then
        echo "$(sed -e 's#tds.content.root.path=.*#tds.content.root.path='${thredds_content_dir}'#' ${thredds_property_file} )" > ${thredds_property_file}
        chown -R ${tomcat_user}:${tomcat_group} ${thredds_property_file}
        chmod 644 ${thredds_property_file}
        echo "configured thredds content root -> $(egrep -e 'tds.content.root.path=.*' ${thredds_property_file})"
    else
        echo "WARNING: Could not file thredds' property file: ${thredds_property_file}"
    fi
    
    echo "Please set the thredds content directory to: ${thredds_content_dir} in the following setup"
    #--------

    #restart tomcat to put modifications in effect.
    stop_tomcat 
    start_tomcat
    start_postgress

    #set in cdms setup (prerequisite)
    echo "$cdat_home/bin/esgsetup --thredds --publish --gateway ${myproxy_endpoint}"
    $cdat_home/bin/esgsetup --thredds --publish --gateway ${myproxy_endpoint}

    chown -R ${tomcat_user}:${tomcat_group} ${thredds_content_dir}

    popd >& /dev/null
    echo
    mkdir -p ${thredds_root_dir}
    [ $? != 0 ] && echo " Error: could not create ${thredds_root_dir}" && checked_done 1
    mkdir -p ${thredds_replica_dir}
    [ $? != 0 ] && echo " Error: could not create ${thredds_replica_dir}" && checked_done 1
    echo

    #Set ownership of esgcet "thredds content" directory to installation owner
    mkdir -p ${thredds_content_dir}/thredds/esgcet
    echo "chown -R ${installer_uid}:${installer_gid} ${thredds_content_dir}/thredds/esgcet"
    chown -R ${installer_uid}:${installer_gid} ${thredds_content_dir}/thredds/esgcet 
    [ $? != 0 ] && echo "WARNING: Could not change owner successfully - this will lead to unability to create new catalogs via the publisher!"

    echo "curl http://${node_host_ip_address}/thredds"
    local wait_time=5
    local ret=1
    while [[ $wait_time > 0 ]]; do
        curl http://${node_host_ip_address}/thredds >& /dev/null
        ret=$?
        [ $ret == 0 ] && break
        sleep 1
        ((wait_time--))
    done

    [ $? != 0 ] && echo "[FAILED]" && echo " ERROR: Not able to contact thredds page on this server" && checked_done 1
    echo "[OK]"
    write_tds_env
    write_tds_install_log
    checked_done 0
}

write_tds_env() {
    ((show_summary_latch++))
    echo "export ESG_GATEWAY_NAME=${gateway_name}" >> ${envfile}
    echo "export ESG_GATEWAY_SVC_ROOT=${gateway_service_root}" >> ${envfile}
    echo "export myproxy_port=${myproxy_port}" >> ${envfile}
    dedup ${envfile} && source ${envfile}
    return 0
}

write_tds_install_log() {
    echo "$(date ${date_format}) webapp:thredds=${tds_version} ${tomcat_install_dir}/webapps/${thredds_dist_file%.*}" >> ${install_logfile}
    dedup ${install_logfile}
    return 0
}

test_tds() {
    echo
    echo "----------------------------"
    echo "Thredds Data Server Test... (publisher catalog gen)"
    echo "----------------------------"
    echo
    mkdir -p ${workdir}
    [ $? != 0 ] && checked_done 1
    pushd ${workdir} >& /dev/null

    start_tomcat
    start_postgress

    echo "$cdat_home/bin/esgpublish --use-existing pcmdi.${esg_root_id}.test.mytest --noscan --thredds"
    $cdat_home/bin/esgpublish --use-existing pcmdi.${esg_root_id}.test.mytest --noscan --thredds
    [ $? != 0 ] && echo "[FAILED]" && echo " ERROR: Not able to run esgpublish command" && popd && checked_done 1
    sleep 2
    echo "curl http://${node_host_ip_address}/thredds"
    curl http://${node_host_ip_address}/thredds
    [ $? != 0 ] && echo "[FAILED]" && echo " ERROR: Not able to contact thredds page on this server" && popd && checked_done 1
    
    echo "[OK]"
    popd >& /dev/null
    echo
    echo
    checked_done 0
}






#####
# Globus Toolkit ->  MyProxy (client) & GridFTP (server)
#####
# Takes arg <selection bit vector> 
# The rest of the args are the following...
# for data-node configuration (GridFTP stuff): ["with-bdm-config"|"bdm-config-only"] see esg-globus script
# for idp configuration (MyProxy stuff): [gen-self-cert] <dir> | [regen-simpleca] [fetch-certs|gen-self-cert] | ["install"|"update"])
setup_globus() {
    local sel=${1:-${sel:-0}}
    echo "setup_globus for sel type ${sel}"
    ((sel == 0)) && echo "setup_globus: no selection set, returning (1)" && return 1
    shift
    
    mkdir -p ${workdir}
    [ $? != 0 ] && checked_done 1
    pushd ${workdir} >& /dev/null
    
    pushd ${scripts_dir} >& /dev/null
    local fetch_file=esg-globus
    checked_get ./${fetch_file} ${esg_dist_url}/externals/bootstrap/${fetch_file}
    (( $? > 1 )) && popd && return 1
    chmod 755 ${fetch_file}
    popd >& /dev/null
    
    local directive="notype"
    local ret=1
    
    if [ $((sel & DATA_BIT))  != 0 ]; then
        echo -n "Globus Setup for Data-Node... (GridFTP server) "
        directive="datanode"
        pushd ${workdir} >& /dev/null
        source ${scripts_dir}/${fetch_file} && setup_globus_services "${directive}" $@
        ret=$?
        popd >& /dev/null
        [ ${ret} = 0 ] && write_globus_env || checked_done 1
        touch ${globus_location}/esg_${progname}_installed
    fi

    ret=1

    if [ $((sel & IDP_BIT)) != 0 ]; then
        echo -n "Globus Setup for Index-Node... (MyProxy server) "
        directive="gateway"
        pushd ${workdir} >& /dev/null
        source ${scripts_dir}/${fetch_file} && setup_globus_services "${directive}" $@
        ret=$?
        popd >& /dev/null
        [ ${ret} = 0 ] && write_globus_env || checked_done 1
        touch ${globus_location}/esg_${progname}_installed
    fi
    return 0
}

write_globus_env() {
    ((show_summary_latch++))
    echo "export GLOBUS_LOCATION=$GLOBUS_LOCATION" >> ${envfile}
    echo "export X509_CERT_DIR=$X509_CERT_DIR" >>  ${envfile}
    echo "export gridftp_config_args=$gridftp_config_args" >> ${envfile}
    dedup ${envfile} && source ${envfile}
    return 0
}

test_globus() {
    local sel=${1:-${sel:-0}}
    ((sel ==0)) && echo "test_globus: no selection set, returning (1)" && return 1
    shift

    local ret=1

    local directive="notype"
    if [ $((sel & DATA_BIT))  != 0 ]; then
        echo "Testinging Globus Services for Data-Node... (GridFTP server(s)) : [$@]"
        directive="datanode"
        mkdir -p ${workdir}
        [ $? != 0 ] && checked_done 1
        pushd ${workdir} >& /dev/null
        source ${scripts_dir}/esg-globus && test_globus_services "${directive}" $@
        ret=$?
        popd >& /dev/null
    fi

    ((ret)) && checked_done $ret

    if [ $((sel & IDP_BIT)) != 0 ]; then
        echo "Testing Globus Services for Index-Node... (MyProxy server)"
        directive="gateway"
        mkdir -p ${workdir}
        [ $? != 0 ] && checked_done 1
        pushd ${workdir} >& /dev/null
        source ${scripts_dir}/esg-globus && test_globus_services "${directive}" $@
        ret=$?
        popd >& /dev/null
    fi
    checked_done $ret
}

# Starts the globus services by delegating out to esg-globus script
# arg1 selection bit vector ($sel)
# args* (in the context of data node ->  ["with-bdm-config"|"bdm-config-only"])
start_globus() {
    local sel=${1:-${sel:-0}}
    ((sel == 0)) && echo "start_globus: no selection set, returning (1)" && return 1
    shift

    local data_node_ret=1
    local directive="notype"
    if [ $((sel & DATA_BIT))  != 0 ]; then
        echo "Starting Globus Services for Data-Node... (GridFTP server(s)) : [$@]"
        directive="datanode"
        mkdir -p ${workdir}
        [ $? != 0 ] && checked_done 1
        pushd ${workdir} >& /dev/null
        source ${scripts_dir}/esg-globus && start_globus_services "${directive}" $@
        data_node_ret=$?
        [ ${data_node_ret} != 0 ] && echo "Could Not Start Globus Data Node related services (GridFTP)"
        popd >& /dev/null
    fi


    local idp_node_ret=1
    if [ $((sel & IDP_BIT)) != 0 ]; then
        echo "Starting Globus Services for Index-Node... (MyProxy server)"
        directive="gateway"
        mkdir -p ${workdir}
        [ $? != 0 ] && checked_done 1
        pushd ${workdir} >& /dev/null
        source ${scripts_dir}/esg-globus && start_globus_services "${directive}" $@
        idp_node_ret=$?
        [ ${idp_node_ret} != 0 ] && echo "Could Not Start Globus IDP Node related services (MyProxy)"
        popd >& /dev/null
    fi

}

# Stops the globus services by delegating out to esg-globus script
# arg1 selection bit vector ($sel)
stop_globus() {
   local sel=${1:-0}
    ((sel ==0)) && echo "stop_globus: no selection set, returning (1)" && return 1
    shift

    local ret=1

    local directive="notype"
    if [ $((sel & DATA_BIT))  != 0 ]; then
        echo -n "Stopping Globus Services for Data-Node... (GridFTP) "
        directive="datanode"
        mkdir -p ${workdir}
        [ $? != 0 ] && checked_done 1
        pushd ${workdir} >& /dev/null
        source ${scripts_dir}/esg-globus && stop_globus_services "${directive}" $@
        ret=$?
        popd >& /dev/null
    fi

    if [ $((sel & IDP_BIT)) != 0 ]; then
        echo "Stopping Globus Services for Index-Node... (MyProxy server)"
        directive="gateway"
        mkdir -p ${workdir}
        [ $? != 0 ] && checked_done 1
        pushd ${workdir} >& /dev/null
        source ${scripts_dir}/esg-globus && stop_globus_services "${directive}" $@
        ret=$?
        popd >& /dev/null
    fi

}

#####
# Test Publication
#####

test_publication() {
    echo
    echo "----------------------------"
    echo "Publication test... $@"
    echo "----------------------------"
    echo
    [ -z "${myproxy_user}" ] && read -p "Enter your myproxy username: " myproxy_user

    local personal_credential_repo="$HOME/.globus"

    mkdir -p ${personal_credential_repo}
    chown -R ${installer_uid}:${installer_gid} ${personal_credential_repo}

    [ "$(ls -A ${X509_CERT_DIR})" ] && echo "Detected existing content in \$X509_CERT_DIR" || rmdir ${X509_CERT_DIR}
    
    echo "X509_CERT_DIR = ${X509_CERT_DIR}"
    echo "$globus_location/bin/myproxy-logon -s $myproxy_endpoint -l $myproxy_user -p $myproxy_port -o ${personal_credential_repo}/certificate-file -T"
    $globus_location/bin/myproxy-logon -s $myproxy_endpoint -l $myproxy_user -p $myproxy_port -o ${personal_credential_repo}/certificate-file -T
    [ $? != 0 ] && echo " ERROR: MyProxy not setup properly.  Unable to execute command." && return 1

    chown -R ${installer_uid}:${installer_gid} ${personal_credential_repo}

    #Publish the dataset from the THREDDS catalog created above...
    echo "$cdat_home/bin/esgpublish --use-existing pcmdi.${esg_root_id}.test.mytest --noscan --publish"
    $cdat_home/bin/esgpublish --use-existing pcmdi.${esg_root_id}.test.mytest --noscan --publish
    [ $? != 0 ] && echo " ERROR: unable to successfully execute esgpublish" && return 1
    sleep 3

    [ "$1" = "no-unpublish" ] && echo "Leaving test publication file published" && return 1
    echo "$cdat_home/bin/esgunpublish --skip-thredds pcmdi.${esg_root_id}.test.mytest"
    $cdat_home/bin/esgunpublish --skip-thredds pcmdi.${esg_root_id}.test.mytest
    [ $? != 0 ] && echo " ERROR: unable to successfully execute esgunpublish" && return 1

    return 0
}

#NOTE: Here we are enforcing a bit of a convention... The name of
#subsystem files must be in the form of esg-xxx-xxx where the script
#contains its "main" function named setup_xxx_xxx(). The string passed
#to this function is "xxx-xxx"
#
#arg (1) - name of installation script root name. Ex:security which resolves to script file esg-security
#arg (2) - [optional] directory on the distribution site where script is fetched from Ex: orp
#usage: setup_subsystem security orp - looks for the script esg-security in the distriubtion dir orp
setup_subsystem() {
    local subsystem=$1
    [ -z "${subsystem}" ] && echo "setup_subsystem [${subsystem}] requires argument!!" && checked_done 1
    local server_dir=${2:-"${subsystem}"}
    
    echo
    read -p "Would you like to set up ${subsystem} services? [Y/n] " dosetup
    if [ "${dosetup}" = "N" ] || [ "${dosetup}" = "n" ] || [ "${dosetup}" = "no" ]; then
        return 0
    fi    

    #if [ "${dosetup}" != "Y" ] && [ "${dosetup}" != "y" ]; then
    #   echo "Skipping ${subsysem} installation"
    #   return 0
    #fi
    echo

    echo -n "${subsystem} setup for Data-Node... "
    mkdir -p ${workdir}
    [ $? != 0 ] && checked_done 1
    pushd ${workdir} >& /dev/null

    pushd ${scripts_dir} >& /dev/null
    local fetch_file=esg-${subsystem}
    checked_get ./${fetch_file} ${esg_dist_url}/${server_dir}/${fetch_file}
    (( $? > 1 )) && popd && return 1
    chmod 755 ${fetch_file}
    popd >& /dev/null

    #source subsystem file and go!
    shift && echo "-->>> "
    shift && echo "-->>> "
    source ${scripts_dir}/${fetch_file} && echo ":-) " && setup_${subsystem//'-'/_} $@
    checked_done $?
}

#####
# Show user summary and environment variables that have been set
#####
show_summary() {
    if [ $((show_summary_latch == 0)) = 1 ]; then return 0; fi
    echo 
    echo "-------------------"
    echo "  esg-node run summary: "
    echo "-------------------"
    echo "The following environment variables were used during last full install"
    echo "They are written to the file ${envfile}"
    echo "Please source this file when using these tools"
    echo 
    cat ${envfile}
    echo "-------------------"
    echo "Installation Log:"
    echo 
    cat ${install_logfile}
    echo "-------------------"
    echo 
    return 0
}

write_env() {
    echo "Generating default ${envfile} file"
    [ -e ${envfile} ] && cp ${envfile} ${envfile}.bak
    cat /dev/null > ${envfile}
    write_paths
    write_git_env
    write_java_env
    write_ant_env
    write_postgress_env
    write_esgcet_env
    write_tomcat_env
    write_tds_env
    write_globus_env
    echo "-------------------"
    cat ${envfile}
    echo "-------------------"
    return 0
}


############################################
# Certificate Management Utility Functions
############################################

#Goes to ESG distribution server and pulls down all certificates for the federation.
#(suitable for crontabbing)
fetch_esg_certificates() {
    echo 
    echo "Fetching Freshest ESG Federation Certificates..."
    #globus_global_certs_dir=/etc/grid-security/certificates
    [ -d ${globus_global_certs_dir} ] && tar czf ${globus_global_certs_dir%/*}/${globus_global_certs_dir##*/}.bak.tgz ${globus_global_certs_dir} >& /dev/null && rm ${globus_global_certs_dir}/*
    mkdir -p ${globus_global_certs_dir}
    local esg_trusted_certs_file=esg_trusted_certificates.tar.gz
    (($DEBUG)) && echo "curl -s -L --insecure ${esg_dist_url}/certs/${esg_trusted_certs_file} | zcat | (cd ${globus_global_certs_dir}; pax -r -s ',.*/,,p')"
    curl -s -L --insecure ${esg_dist_url}/certs/${esg_trusted_certs_file} | zcat | (cd ${globus_global_certs_dir}; pax -r -s ',.*/,,p')
    local ret=$?
    rmdir ${globus_global_certs_dir}/$(echo ${esg_trusted_certs_file} | awk 'gsub(/('$compress_extensions')/,"")')
    if [ $ret == 0 ]; then
        [ -e ${globus_global_certs_dir%/*}/${globus_global_certs_dir##*/}.bak.tgz ] && rm ${globus_global_certs_dir%/*}/${globus_global_certs_dir##*/}.bak.tgz
    fi
    chmod 755 ${globus_global_certs_dir}
    chmod 644 ${globus_global_certs_dir}/*
}

#Converts ESG certificates (that can be fetch by above function) into a truststore
#(adapted from original rendition by Philip Kershaw)
rebuild_truststore() {
    echo
    echo "Rebuilding truststore from esg certificates..."
    if [ ! -d ${globus_global_certs_dir} ] || (( force_install )) ; then
        [ ! -d ${globus_global_certs_dir} ] && echo "Sorry, No esg certificates found... in ${globus_global_certs_dir}" || echo "(forcing fresh rebuild)"
        echo "So fetching fresh esg certificates :-)"
        fetch_esg_certificates
    fi

    #If you don't already have a truststore to build on....
    #Start building from a solid foundation i.e. Java's set of ca certs...
    [ ! -e ${truststore_file} ] && cp -v ${java_install_dir}/jre/lib/security/cacerts ${truststore_file}

    local tmp_dir=/tmp/esg_scratch
    mkdir -p ${tmp_dir}

    local cert_files=$(find ${globus_global_certs_dir} | egrep '^.*.0$')
    for cert_file in $cert_files; do
        echo -n "$cert_file -> "
        local cert_hash=$(echo ${cert_file##*/} | awk -F'.' '{print $1}') ;
        local der_file="${tmp_dir}/${cert_hash}.der" ;

        #--------------
        # Convert from PEM format to DER format - for ingest into keystore
        openssl x509 -inform pem -in ${cert_file} -outform der -out ${der_file}
        #--------------

        if [ -f ${truststore_file} ]; then
            keytool -delete -alias ${cert_hash} -keystore ${truststore_file} \
                -storepass changeit 2>&1 > /dev/null ;
            [ $? == 0 ] && echo -n "- " || echo -n "  "
        fi

        [ $? == 0 ] && echo -n "+ " || echo -n "  "
        keytool -import -alias ${cert_hash} -file ${der_file} -keystore ${truststore_file} \
            -storepass changeit -noprompt ;
        [ $? != 0 ] && echo " [FAILED]"

        rm -f ${der_file} ;
    done
    rmdir ${tmp_dir}

    chown ${tomcat_user}:${tomcat_group} ${truststore_file}
    echo "...done"
    return 0
}

#This takes our certificate from the keystore and adds it to the
#truststore.  This is done for other services that use originating
#from this server talking to another service on this same host.  This
#is the interaction scenario with part of the ORP security mechanism.
#The param here is the password of the *keystore*
add_my_cert_to_truststore() {
    echo 
    (($DEBUG)) && echo "add_my_cert_to_truststore() "
    local store_password=${1}

    if [ -z "${store_password}" ]; then
        local verify_password
        while [ 1 ]; do
            echo
            read -s -p "Please enter the password for this keystore   : " store_password
            [ "${store_password}" = "changeit" ] && break
            [ -z "${store_password}" ] && echo "Invalid password [${store_password}]" && continue
            echo
            read -s -p "Please re-enter the password for this keystore: " verify_password
            if [ "${store_password}" = "${verify_password}" ] ; then
                echo
                break
            else
                echo "Sorry, values did not match"
                echo
            fi
        done
        unset verify_password
        echo
    else 
        echo "store_password = ******"
    fi

    #only making this call to test password
    keytool -v -list -keystore ${keystore_file} -storepass ${store_password} >& /dev/null
    [ $? != 0 ] && echo "Could not access private keystore ${keystore_file}" && return 1;

    #----------------------------------------------------------------
    #Re-integrate my public key (I mean, my "certificate") from my keystore into the truststore (the place housing all public keys I allow to talk to me)
    #----------------------------------------------------------------
    if [ -e ${truststore_file} ]; then
        echo "Re-Integrating keystore's certificate into truststore.... "
        echo "Extracting keystore's certificate... "
        keytool -export -alias ${keystore_alias} -file ${keystore_file}.cer -keystore ${keystore_file} -storepass ${store_password}
        [ $? == 0 ] && echo "[OK]" || (echo "[FAILED]" && exit 1)

        echo "keytool -v -list -keystore ${truststore_file} -storepass changeit | egrep -i '^Alias[ ]+name:[ ]+my_esgf_node$'"
        keytool -v -list -keystore ${truststore_file} -storepass changeit | egrep -i '^Alias[ ]+name:[ ]+my_esgf_node$' #TODO howdo I put the var ${keystore_alias} here!!!
        if [ $? == 0 ]; then
            echo "Detected Alias \"${keystore_alias}\" Present... Removing... Making space for certificate... "
            keytool -delete -alias ${keystore_alias} -keystore ${truststore_file}  -storepass changeit 2>&1 > /dev/null #for ORP
            [ $? != 0 ] && echo " ERROR: problem deleting ${keystore_alias} key from keystore!" && return 1
        fi

        echo "Importing keystore's certificate into truststore... "
        keytool -import -v -trustcacerts -alias ${keystore_alias} -keypass ${store_password} -file ${keystore_file}.cer -keystore ${truststore_file} -storepass changeit -noprompt
        [ $? == 0 ] && echo "[OK]" || (echo "[FAILED]" && exit 1)
        sync_with_java_truststore ${truststore_file}
        echo -n "cleaning up after ourselves... "
        rm -v ${keystore_file}.cer
        [ $? == 0 ] && echo "[OK]" || echo "[FAILED]"
    fi
    chown ${tomcat_user}:${tomcat_group} ${truststore_file}
    #----------------------------------------------------------------
    return 0
}

#---
#Original command instructions can be found here:
#http://www.sial.org/howto/openssl/csr/ 
#arg 1 -> what we want to name the private key
#arg 2 -> what we want to name the public cert
#arg 3 -> what we want the DN to be for public cert
generate_ssl_key_and_csr() {
    echo "Generating private host key... "
    local private_key=${1:-${tomcat_conf_dir}/hostkey.pem}
    openssl genrsa -out ${private_key} 1024
    [ $? == 0 ] && echo "[OK]" || (echo "[FAILED]" && return 1)
    chmod 400 ${private_key}

    #NOTE: To include DN at the command line
    #openssl req -new -nodes -subj '/O=Grid/OU=GlobusTest/OU=simpleCA-pcmdi3.llnl.gov/CN=esg-test1.llnl.gov' -key hostkey.pem -out esg-test1.llnl.gov-esg-node.csr
    echo "Generating Certificate Signing Request (csr)... "
    local public_cert_req=${2:-${tomcat_conf_dir}/$(hostname --fqdn)-esg-node.csr}
    local public_cert_dn=${3:-$(extract_keystore_dn ${keystore_file})}

    echo "Using DN = [${public_cert_dn}]"

    #At this point public_cert_dn is empty if extract_keystore_dn was unable to perform successfully
    #So then we run the regular request generation that will ask you a series of questions to build the DN
    if [ -z "${public_cert_dn}" ]; then
        echo "openssl req -new -nodes -key ${private_key} -out ${public_cert_req}"
        openssl req -new -nodes -key ${private_key} -out ${public_cert_req}
        [ $? == 0 ] && echo "[OK]" || (echo "[FAILED]" && return 2)
    else
        #Or, there was indeed an extraction of the DN from the keytool or I manually provided the DN
        #So then generate the request with the DN...
        echo "openssl req -new -nodes -subj ${public_cert_dn} -key ${private_key} -out ${public_cert_req}"
        openssl req -new -nodes -subj "${public_cert_dn}" -key ${private_key} -out ${public_cert_req}
        [ $? == 0 ] && echo "[OK]*" || (echo "[FAILED]*" && return 2)
    fi
    chmod 644 ${public_cert_req} >& /dev/null
    echo
    echo "--------------------------------------------------------"
    echo "In Directory: $(pwd)"
    echo "Generated private key: $(ls ${private_key})"
    echo "Generated certificate: $(ls ${public_cert_req})"
    echo "Please submit the certificate request to your Certificate Authority:"
    echo "Then run %> esg-node --install-keypair <private key> <signed cert> (use --help for details)"
    echo "--------------------------------------------------------"
    echo
    #echo "Generating temporary self-signed certificate... "
    #openssl x509 -req -days 30 -in ${public_cert_req} -signkey ${private_key} -out ${public_cert_req%.*}.pem
    #[ $? == 0 ] && echo "[OK]" || (echo "[FAILED]" && return 3)
    #openssl x509 -noout -text -in ${public_cert_req%.*}.pem

}

#------
#HELPER / UTILITY FUNCTION (aka private)
#------
#arg 1 -> the location of the java keystore file
#arg 2 -> the password to the java keystore file
extract_keystore_dn() {
    #TODO: check to see if there is a java keystore present... If so
    #read the store and pull out the "Owner:" DN and use it as the DN
    #for this new cert being generated. (perhaps ask the user if they
    #want to use the 'discovered' DN)
    local dn=""
    local keystore_file=${1:-${keystore_file}}
    if [ -e ${keystore_file} ]; then 
        local storepass=${2}
        local storepass_switch=""
        #If no password is provided then we want to at least make sure the command line is clean such that keytool will ask you for a password
        #this is a bit of defensive coding so we don't run into the problem of not having the password and running a broken arg sequence
        [ -n "${storepass}" ] && storepass_switch="-storepass ${storepass}"
        #Note: I apologize for this horribile hacking of regex (this should be more cleanly accomplished with sed or perl using a capture group or a simple look behind)
        dn=$(keytool -list -v -keystore ${keystore_file} ${storepass_switch} | egrep -e '^Owner:[ ]*?*' | tr -s " " | sed -e 's#^Owner: ##' | sed -e s#", "#" "#g | tac -s " " | xargs | sed -e 's# #/#g')
    fi
    echo "/${dn}"
}

#(Once you have submitted the CSR and have gotten it back *signed*; now install the keypair)
#arg 1 -> private key
#arg 2 -> public cert (the returned signed CSR)
#arg 3 -> keystore name
#arg 4 -> alias
#arg 5 -> password (The value you want *set* for the keystore and internal private key)
install_keypair() {
    local private_key=${1:-${tomcat_conf_dir}/"hostkey.pem"}
    local public_cert=${2:-${tomcat_conf_dir}/"$(hostname --fqdn)-esg-node.pem"}
    local keystore_name=${3:-${keystore_file}}
    local keystore_alias=${4:-${keystore_alias}}
    local store_password=${5}

    echo "private key = ${private_key}"
    echo "public cert = ${public_cert}"
    echo "keystore name  = ${keystore_file}"
    echo "keystore alias = ${keystore_alias}"

    local ks_secret=$(cat ${ks_secret_file} 2> /dev/null)
    local default_passwd=${ks_secret:=changeit}

    if [ -z "${store_password}" ]; then
        local verify_password
        while [ 1 ]; do
            echo
            read -s -p "Please enter the password for this keystore   : " store_password
            [ "${store_password}" = "${default_passwd}" ] && break
            [ -z "${store_password}" ] && echo "Invalid password [${store_password}]" && continue
            echo
            read -s -p "Please re-enter the password for this keystore: " verify_password
            if [ "${store_password}" = "${verify_password}" ] ; then
                echo
                break
            else
                echo "Sorry, values did not match"
                echo
            fi
        done
        unset verify_password
        echo
    else 
        echo "store_password = ******"
    fi

    local certfiles=()
    local certfile_entry
    echo "Please enter your Certificate Athority's certificate chain file(s): "
    echo " [enter each cert file/url press return, press return with blank entry when done]"
    echo
    while [ 1 ]; do
        read -p "certfile> " certfile_entry
        [ -z ${certfile_entry} ] && break
        certfiles=("${certfiles[@]} ${certfile_entry}")
    done
    ((DEBUG)) && echo "make_fresh_keystore ${keystore_name} ${keystore_alias} ${store_password} ${private_key} -- ${public_cert} ${certfiles[@]}"
    make_fresh_keystore ${keystore_name} ${keystore_alias} ${store_password} ${private_key} -- ${public_cert} ${certfiles[@]}
    [ $? != 0 ] && echo "ERROR: Problem with key generation and/or keystore construction" && mv ${keystore_name}.bak ${keystore_name} && exit 5
    
    ##Transform the keypair into the DER format understood by Java's keystore
    ##And generate a new keystore from that pair.
    #[ -e "${keystore_name}" ] && mv ${keystore_name} ${keystore_name}.bak
    #convert_keys ${private_key} ${public_cert} && \
    #    create_keystore ${private_key%.*}.der ${public_cert%.*}.der ${keystore_name} ${keystore_alias} ${store_password} 
    #[ $? != 0 ] && echo "ERROR: Problem with key generation and/or keystore construction" && mv ${keystore_name}.bak ${keystore_name} && exit 5

    echo "${store_password}" > ${ks_secret_file}
    chmod 600 ${ks_secret_file}
    chown ${installer_uid}:${installer_gid} ${ks_secret_file}
    
    #(In order for ORP or any other local service to trust eachother put your own cert into the truststore)
    [ -e "${truststore_file}" ] && mv ${truststore_file} ${truststore_file}.bak
    rebuild_truststore && add_my_cert_to_truststore ${store_password}
    [ $? != 0 ] && echo "ERROR: Problem with truststore generation" && mv ${truststore_file}.bak ${truststore_file} && exit 6
    register
    
    #--------------------------------------------------
    #Copy the files to where they need to go for GLOBUS 
    #--------------------------------------------------
    local globus_grid_security_dir=${globus_global_certs_dir%/*}
    [ ! -d  ${globus_grid_security_dir} ] && echo "ERROR: Could not locate target globus key location:[${globus_grid_security_dir}]" && exit 6

    [ -e ${globus_grid_security_dir}/hostkey.pem ] && mv ${globus_grid_security_dir}/hostkey.pem ${globus_grid_security_dir}/hostkey.pem.old
    cp -v ${private_key} ${globus_grid_security_dir}/hostkey.pem && \
        chmod 600 ${globus_grid_security_dir}/hostkey.pem

    [ -e ${globus_grid_security_dir}/hostcert.pem ] && mv ${globus_grid_security_dir}/hostcert.pem ${globus_grid_security_dir}/hostcert.pem.old
    cp -v ${public_cert} ${globus_grid_security_dir}/hostcert.pem && \
        chmod 644 ${globus_grid_security_dir}/hostcert.pem && \
        openssl x509 -noout -text -in ${globus_grid_security_dir}/hostcert.pem

    echo "Please restart this node for keys to take effect: \"$0 restart\""
    echo
}

#The following helper function creates a new keystore for your tomcat installation
make_fresh_keystore() {
    
    #-------------
    #Set default values such that env vars may be used
    #-------------
    local keystore_name
    local keystore_alias
    local store_password
    local private_key

    local provider="org.bouncycastle.jce.provider.BouncyCastleProvider"
    local install_dir=${esg_tools_dir}/idptools

    #-------------
    #Collect args...
    #-------------
    local certfiles=()
    local arg_length=$#
    for ((i=1; i <= ${arg_length} ; i++)) ; do 
	[ "$1" = "--" ] && shift && certfiles=($@) && break
	((i==1)) && keystore_name=$1 && shift
	((i==2)) && keystore_alias=$1 && shift
	((i==3)) && store_password=$1 && shift
	((i==4)) && private_key=$1 && shift
    done
    local size=${#certfiles[@]}
    ((DEBUG)) && echo "(certfiles = ${certfiles[@]})"
    [ ! -e "${private_key}" ] && echo "file [${private_key}] does not exist" && return 1
    (( size == 0 )) && echo "no certificate files listed" && usage


    #-------------
    #Display values
    #-------------
    echo
    echo "Keystore name : ${keystore_name}"
    echo "Keystore alias: ${keystore_alias}"
    echo "Store password: ${store_password}"
    echo "Private key   : ${private_key}"
    echo "Certificates..."

    mkdir -p ${install_dir}
    [ $? != 0 ] && echo "exiting..." && return 1
    PATH=${PATH}:${install_dir}/bin

    local certbundle="${install_dir}/cert.bundle"
    local ca_chain_bundle="${install_dir}/ca_chain.bundle"
    
    local content
    local skip_check=0
    local count=1
    for ((i=0; i<size; i++)) ; do 
	if ((i == 0)) ; then
	    echo "  Signed Cert -------> ${certfiles[i]}"
            echo "${certfiles[i]}" | egrep '^http' 
            if [ $? == 0 ]; then
                curl -s -k ${certfiles[i]} > ${certbundle} && echo "[OK]"
                skip_check=1
            else
                cat ${certfiles[i]} > ${certbundle}
            fi
            cat /dev/null > ${ca_chain_bundle}
	elif ((i == (size-1) )) ; then
	    echo "  Root Cert   -------> ${certfiles[i]}"
            echo "${certfiles[i]}" | egrep '^http' 
            if [ $? == 0 ]; then
                content=$(curl -s -k ${certfiles[i]})
                [ $? != 0 ] && echo "Cannot connect to ${certfiles[i]}" && return 1

                echo "${content}" | grep "Not Found" >& /dev/null
                [ $? == 0 ] && echo "${content}" && return 1
                
                ((DEBUG)) && echo "** ${content}"

                echo "$content" >> ${certbundle} && \
                    echo "$content" >> ${ca_chain_bundle} && \
                    echo "[OK]"
                skip_check=1
            else
                cat ${certfiles[i]} >> ${certbundle}
                cat ${certfiles[i]} >> ${ca_chain_bundle}
            fi
	else
	    echo "  Intermediate [$((count++))] --> ${certfiles[i]}"
            echo "${certfiles[i]}" | egrep '^http' 
            if [ $? == 0 ]; then
                content=$(curl -s -k ${certfiles[i]})
                [ $? != 0 ] && echo "Cannot connect to ${certfiles[i]}" && return 1
                
                echo "${content}" | grep "Not Found" >& /dev/null
                [ $? == 0 ] && echo "${content}" && return 1
                
                ((DEBUG)) && echo "* ${content}"
                
                echo "$content" >> ${certbundle} && \
                    echo "$content" >> ${ca_chain_bundle} && \
                    echo "[OK]"
                skip_check=1
            else
                cat ${certfiles[i]} >> ${certbundle}
                cat ${certfiles[i]} >> ${ca_chain_bundle}
            fi
	fi
        ((skip_check==0)) && [ ! -e "${certfiles[i]}" ] && echo "file [${certfiles[i]}] does not exist" && return 1
        if ((skip_check==0)) ; then
            ((DEBUG)) && head ${certfiles[i]}
	    ((DEBUG)) && openssl x509 -text -noout -in ${certfiles[i]}
        fi
        skip_check=0
    done
    unset count
    unset content

    #-------------
    # Structural integrity checks...
    #-------------    
    echo
    echo -n "checking that key pair is congruent... "
    local pair_hash=($((openssl x509 -noout -modulus -in ${certfiles[0]} | openssl md5 ; openssl rsa -noout -modulus -in ${private_key} | openssl md5) | uniq))
    (( 1 == ${#pair_hash[@]} )) && printf "[OK] ${pair_hash}\n\n" || (printf "[FAIL]\n\n" && return 1)


    #-------------
    #Let's be a little interactive with users for a sanity check
    #-------------
    local answer="Y"
    read -p "Is the above information correct? [Y/n] " answer
    [ -n "${answer}" ] && [ "${answer}" != "Y" ]  && [ "${answer}" != "y" ]  && echo "exiting..." && return 1
    
    local derkey="${install_dir}/key.der"

    #-------------
    #Make empty keystore...
    #-------------
    echo "creating keystore..."
    #create a keystore with a self-signed cert
    local dname=${dname:-"CN=$(hostname --fqdn), OU=simpleCA-pcmdi3.llnl.gov, OU=GlobusTest, O=Grid"}
    [ -e "${keystore_name}" ] && mv ${keystore_name} ${keystore_name}.bak
    keytool -genkey -keyalg RSA -alias "${keystore_alias}" \
        -keystore "${keystore_name}" \
        -storepass "${store_password}" \
        -keypass "${store_password}" \
        -validity 360 \
        -dname "${dname}" \
        -noprompt
    [ $? != 0 ] && echo "Problem with generating initial keystore... :-(" && return 1

    echo "clearing keystore..."
    #delete the cert
    keytool -delete -alias "${keystore_alias}" -keystore "${keystore_name}" -storepass "${store_password}"
    [ $? != 0 ] && echo "Problem with preparing initial keystore... :-(" && return 1
    
    #-------------
    #Convert your private key into from PEM to DER format that java likes
    #-------------
    echo "converting private key..."
    openssl pkcs8 -topk8 -nocrypt -inform PEM -in ${private_key} -outform DER -out ${derkey} 

    #-------------
    #Now we gather up all the other keys in the key chain...
    #-------------
    echo -n "checking that chain is valid... "
    ((DEBUG)) && echo "openssl verify -CAfile ${ca_chain_bundle} ${ca_chain_bundle}"
    local chain_check=$(openssl verify -CAfile ${ca_chain_bundle} ${ca_chain_bundle} | grep -i error)
    if [ -z "${chain_check}" ]; then  printf "[OK]\n\n"; else  printf "[FAIL] ${chain_check}\n\n"; return 1 ; fi

    
    #-------------
    #Generating new keystore
    #-------------
    echo -n "Constructing new keystore content... "
    local command="extkeytool -importkey -keystore ${keystore_name} -alias ${keystore_alias} -storepass ${store_password} -keypass ${store_password} -keyfile ${derkey} -certfile ${certbundle} -provider ${provider}"
    ((DEBUG)) && echo && echo ${command}

    ${command} > /dev/null
    local ret=$?

    #FYI: Code 127 is "command not found"
    if [ ${ret} == 127 ]; then
        echo "Hmmm... Cannot find extkeytool... :-( Let me get it for you! :-)  [one moment please...]"
        curl -s -L --insecure ${extkeytool_download_url} |  (cd ${install_dir}; tar xvzf -)
        ${command}
        local ret=$?
    fi

    [ ${ret} != 0 ] && echo "Problem with running extkeytool :-(" && return 1
    [ ${ret} == 0 ] && echo "[OK]"
    
    echo
    echo "How do things look?"
    keytool -v -list -keystore "${keystore_name}" -storepass ${store_password}
    if [ $? == 0 ]; then
	echo 
	echo "If Everything looks good... then replace your current tomcat keystore with ${keystore_name} if necessary."
	echo "Don't forget to change your tomcat's server.xml entry accordingly :-)"
	echo "Remember: Keep your private key ${private_key} and signed cert ${certfiles[0]} in a safe place!!!"
	echo
        answer="Y"
        read -p "Is the above information correct? [Y/n] " answer
        [ -n "${answer}" ] && [ "${answer}" != "Y" ]  && [ "${answer}" != "y" ]  && echo "Eh... try again... ;-)" && return 1
    else
	echo 
	echo "Hmmm... something didn't quite go so right... double check things..."
        return 1
    fi
    return 0
}

#************
#(DEPRECATED)
#************
#------
#HELPER FUNCTION (aka private)
#------
#converts key pairs from PEM format to DER format
#(DER format is amenable to Java's keystore mechanism)
#Original command instructions can be found here:
#http://www.ci.uchicago.edu/wiki/bin/view/ESGProject/JarSigningNotes
#arg 1 -> private key
#arg 2 -> public cert
convert_keys() {
    echo -n "Converting private key from PEM -> DER format... "
    local private_key=${1:-"hostkey.pem"}
    [ ! -e ${private_key} ] && echo "Sorry, cannot find ${private_key}" && return 2
    openssl pkcs8 -topk8 -nocrypt -in ${private_key} -inform PEM -out ${private_key%.*}.der -outform DER
    [ $? == 0 ] && echo "[OK]" || (echo "[FAILED]" && return 1)

    echo -n "Converting public cert from PEM -> DER format... "
    local public_cert=${2:-$(hostname --fqdn)-esg-node.pem}
    [ ! -e ${public_cert} ] && echo "Sorry, cannot find ${public_cert}" && return 2
    openssl x509 -in ${public_cert} -inform PEM -out ${public_cert%.*}.der -outform DER
    [ $? == 0 ] && echo "[OK]" || (echo "[FAILED]" && return 1)

    echo
    pwd
    ls -l ${private_key%.*}.der ${public_cert%.*}.der
    echo
    return 0
}

#************
#(DEPRECATED)
#************
#------
#HELPER FUNCTION (aka private)
#------
#Creates a new keystore based on given keypair
#Original command instructions can be found here:
#http://www.agentbob.info/agentbob/79-AB.html
#arg 1 -> private key
#arg 2 -> public cert
#arg 3 -> keystore name*
#arg 4 -> alias*
#arg 5 -> password* (for keystore and private key)
#[*Have default values - non manditory]
create_keystore() {
    local private_key=${1:-"hostkey.der"}
    local public_cert=${2:-$(hostname --fqdn)-esg-node.der}
    local keystore_name=${3:-${keystore_file}}
    local key_alias=${4:-${keystore_alias}}
    local password=${5:-${keystore_password}}
    
    checked_get ${utils_url}/ImportKey.class
    (( $? > 1 )) && echo "Could not fetch keystore generator" && return 1

    [ ! -e ${private_key} ] && echo "Sorry, cannot find ${private_key}" && return 2
    [ ! -e ${public_cert} ] && echo "Sorry, cannot find ${public_cert}" && return 2

    CLASSPATH=. java -Dkeystore=${keystore_name} ImportKey ${private_key} ${public_cert} ${key_alias} ${password}
    [ $? != 0 ] && echo "[FAILED] Could not execute keystore generator" && return 1
    echo
    keytool -list -v -keystore ${keystore_name} -storepass ${password}
    return 0
}

#---

#************
#(DEPRECATED)
#************
#Once the generated CSR has been submitted to a CA and signed... the returned
#signed certificate needs to be imported into the *existing* keystore. (and to trust store: for ORP)
#arg 1 -> signed certificate file returned to you by your CA
install_signed_certificate() {
    local signed_cert_file=${1:-${HOME}/$(hostname --fqdn)-esg-node.pem}

    echo
    echo "Installing Signed Host Certificate: ${signed_cert_file} "
    
    [ ! -e ${signed_cert_file} ] && echo "ERROR: Could not find signed cert file: ${signed_cert_file}" && return 1
    
    local store_password=${keystore_password}
    local verify_password
    while [ 1 ]; do
        echo
        read -s -p "Please enter the password for this keystore   : " store_password
        [ "${store_password}" = "changeit" ] && break
        [ -z "${store_password}" ] && echo "Invalid password [${store_password}]" && continue
        echo
        read -s -p "Please re-enter the password for this keystore: " verify_password
        if [ "${store_password}" = "${verify_password}" ] ; then
            echo
            break
        else
            echo "Sorry, values did not match"
            echo
        fi
    done
    unset verify_password
    echo

    
    if [ -z "$(echo ${signed_cert_file##*.} | egrep "($certificate_extensions)")" ]; then
        #--------------
        #convert from PEM format to a DER format  - for ingeest into the keystores :-)
        echo "converting certificate from PEM format to DER format..."
        echo "openssl x509 -in ${signed_cert_file} -inform PEM -out ${signed_cert_file%.*}.der -outform DER"
        openssl x509 -inform PEM -in ${signed_cert_file} -outform DER -out ${signed_cert_file%.*}.der 
        [ $? == 0 ] && signed_cert_file=${signed_cert_file%.*}.der
        #--------------
    else
        echo "Apparently (based on file extension) this file is already in DER format"
    fi

    [ -e ${keystore_file} ] && echo "(making backup copy of keystore)" && cp -v ${keystore_file} ${keystore_file}.bak

    #--------------
    keytool -v -list -keystore ${tomcat_conf_dir}/keystore-tomcat -storepass changeit | egrep -i '^Alias[ ]+name:[ ]+root$'
    if [ $? == 0 ]; then
        keytool -delete -alias root -keystore ${keystore_file} -storepass ${store_password}
        [ $? != 0 ] && echo " ERROR: problem deleting root key from keystore!" && return 1
    fi
    
    echo "keytool -import -trustcacerts -alias root -file ${signed_cert_file} -keystore ${keystore_file} -storepass *****"
    keytool -import -trustcacerts -alias root -file ${signed_cert_file} -keystore ${keystore_file} -storepass ${store_password}
    local ret=$?
    if [ $ret == 0 ]; then 
        echo "[OK]" 
    else
        echo "[FAILED]"
        echo "(Restoring original keystore)"
        cp -v ${keystore_file}.bak ${keystore_file}
        return $ret
    fi
    
    chown ${tomcat_user}:${tomcat_group} ${keystore_file}
    #--------------

    add_my_cert_to_truststore ${store_password}
    
    unset store_password
    
}

#************
#(DEPRECATED)
#************
#This should only be run AFTER your signed certificate has been already installed into the keystore!
export_keystore_as_globus_hostkeys() {
    mkdir -p ${workdir}
    pushd ${workdir} >& /dev/null
    checked_get ${utils_url}/ExportPriv.class
    (( $? > 1 )) && echo " ERROR: Could not download utility class(1) for exporting certificates" && popd && return 1
    checked_get ${utils_url}/Base64Coder.class
    (( $? > 1 )) && echo " ERROR: Could not download utility class(2) for exporting certificates" && popd && return 1
    popd >& /dev/null

    local CP=".:${workdir}"
    
    [ ! -e ${keystore_file} ] && echo "Cannot locate keystore \"${keystore_file}\"" && return 2
    
    local store_password=${keystore_password}
    local verify_password
    while [ 1 ]; do
        echo
        read -s -p "Please enter the password for this keystore   : " store_password
        [ "${store_password}" = "changeit" ] && break
        [ -z "${store_password}" ] && echo "Invalid password [${store_password}]" && continue
        echo
        read -s -p "Please re-enter the password for this keystore: " verify_password
        if [ "${store_password}" = "${verify_password}" ] ; then
            echo
            break
        else
            echo "Sorry, values did not match"
            echo
        fi
    done
    unset verify_password
    echo
    
    #--------------
    #NOTE: To extract the (private) key from the keystore we use a
    #Java program called ExportPriv.  The result is a PEM formatted
    #private key file that we can directly use.
    #see: http://www.conshell.net/wiki/index.php/Keytool_to_OpenSSL_Conversion_tips

    echo -n "Extracting keystore's key... (private) "
    [ -e ${globus_global_certs_dir%/*}/hostkey.pem ] && cp ${globus_global_certs_dir%/*}/hostkey.pem ${globus_global_certs_dir%/*}/hostkey.pem.last
    [ -e ${globus_global_certs_dir%/*} ] && mkdir -p ${globus_global_certs_dir%/*}
    (($DEBUG)) && \
        printf "\n${JAVA_HOME}/bin/java -classpath ${CP} ExportPriv ${keystore_file} ${keystore_alias} ************* > ${globus_global_certs_dir%/*}/hostkey.pem\n"
    ${JAVA_HOME}/bin/java -classpath ${CP} ExportPriv ${keystore_file} ${keystore_alias} ${store_password} > ${globus_global_certs_dir%/*}/hostkey.pem
    local ret=$?
    [ $ret == 0 ] && echo "[OK]" || echo "[FAILED]"
    chmod 600 ${globus_global_certs_dir%/*}/hostkey.pem
    #--------------

    
    #--------------
    #NOTE: To extract the (public) certificate we use the keytool.
    #Keytool extracts everything (except cert requests) in DER format
    #so, the exporting of this public certificate is no different - it
    #is in DER format, so we must convert.  Hence the openssl calls
    #subsequent to the export.  Also notice that the alias being used
    #is *"root"* this is a special alias that was used when importing
    #the signed certificate (once it was converted from PEM to DER for
    #import)
    
    echo -n "Extracting keystore's certificate... (public) "
    [ -e ${globus_global_certs_dir%/*}/hostcert.pem ] && cp ${globus_global_certs_dir%/*}/hostcert.pem ${globus_global_certs_dir%/*}/hostcert.pem.last
    (($DEBUG)) && \
        printf "\nkeytool -export -alias ${keystore_alias} -file ${globus_global_certs_dir%/*}/hostcert.der -keystore ${keystore_file} -storepass *************\n"
    keytool -export -alias root -file ${globus_global_certs_dir%/*}/hostcert.der -keystore ${keystore_file} -storepass ${store_password}
    ret=$?
    [ $ret == 0 ] && echo "[OK]" || echo "[FAILED]"

    echo -n "Converting DER cert ${globus_global_certs_dir%/*}/hostcert.der to PEM format "
    openssl x509 -in ${globus_global_certs_dir%/*}/hostcert.der -inform DER -out ${globus_global_certs_dir%/*}/hostcert.pem -outform PEM 
    ret=$?
    [ $ret == 0 ] && echo "[OK]" || echo "[FAILED]"
    
    openssl x509 -noout -text -in ${globus_global_certs_dir%/*}/hostcert.pem

    chmod 644 ${globus_global_certs_dir%/*}/hostcert.pem
    #--------------
    
    unset store_password

    #for safe keeping post the truststore and keystore in /etc/grid-security/saved
    if [ -d ${globus_global_certs_dir%/*} ]; then
        mkdir -p ${globus_global_certs_dir%/*}/saved
        chmod 700 ${globus_global_certs_dir%/*}/saved 
        rm ${globus_global_certs_dir%/*}/saved/* >& /dev/null
        cp ${truststore_file} ${globus_global_certs_dir%/*}/saved/${truststore_file##*/}.$(date ${date_format}).bak
        cp ${keystore_file} ${globus_global_certs_dir%/*}/saved/${keystore_file##*/}.$(date ${date_format}).bak
    fi

    echo "(cleanup)"
    rm -v ${globus_global_certs_dir%/*}/hostcert.der

}


#####
# This function is for pulling in keys from hosts we wish to
# communicate with over an encrypted ssl connection.  This function
# must be run after tomcat is set up since it references server.xml.
#####
#(called by setup_tds)
#arg1 - hostname of the machine with the cert you want to get
#(arg2 - password to truststore where cert will be inserted)
register() {
    echo "Installing Public Certificate of Target Gateway Node...( -> MyProxy endpoint: $1)"
    
    mkdir -p ${workdir} # >& /dev/null
    pushd ${workdir} # >& /dev/null
    #Download the Java code used for certificate installation (into $workdir)
    checked_get ${utils_url}/InstallCert.class
    (( $? > 1 )) && echo " ERROR: Could not download utility class(1) for installing certificates" && popd && return 1
    checked_get ${utils_url}/'InstallCert$SavingTrustManager.class'
    (( $? > 1 )) && echo " ERROR: Could not download utility class(2) for installing certificates" && popd && return 1
    popd # >& /dev/null

    pushd ${tomcat_conf_dir} >& /dev/null
    
    local input=${1:-${ESG_GATEWAY_SVC_ROOT%%/*}}
    [ -z "${input}" ] && popd && echo "Could not register: No endpoint specified" && return 1

    local ssl_endpoint=${input%%/*} #just need the hostname
    local ssl_port=${ssl_port:-443}
    local ssl_endpoint_passwd=${2:-changeit}
    
    local CP=".:${workdir}"

    echo "${JAVA_HOME}/bin/java -classpath ${CP} InstallCert ${ssl_endpoint}:${ssl_port} ${ssl_endpoint_passwd} ${truststore_file}"
    ${JAVA_HOME}/bin/java -classpath ${CP} InstallCert ${ssl_endpoint}:${ssl_port} ${ssl_endpoint_passwd} ${truststore_file}
    local ret=$?

    #NOTE: The InstallCert code fetches Java's jssecacerts file (if
    #not there then uses the cacerts file) from java's jre and then adds the target's cert to it.
    #The output of the program is a new file named jssecacerts!  So here we get the output and rename it.
    
    chmod 644 ${truststore_file}
    chown ${tomcat_user}:${tomcat_group} ${truststore_file}
    
    sync_with_java_truststore ${truststore_file}

    popd >& /dev/null
    return $ret
}

#arg 1 - The truststore file to sync with Java's
sync_with_java_truststore() {
    local java_truststore=${JAVA_HOME}/jre/lib/security/jssecacerts
    local external_truststore=${1:-$(readlink -f ${truststore_file})}
    echo -n "Sync'ing ${external_truststore} with ${java_truststore} ... "
    [ ! -e "${external_truststore}" ] && echo "[FAIL]: Cannot locate ${external_truststore}" && return 1
    [ -e "${java_truststore}" ] && cp ${java_truststore} ${java_truststore}.bak
    cp ${external_truststore} ${java_truststore}
    chmod 644 ${java_truststore}
    chown -R ${installer_uid}:${installer_gid} ${java_truststore}*
    echo "[OK]"
}

############################################
# General - Utility Functions
############################################

#NOTE: This is another **RedHat/CentOS** specialty thing (sort of)
#arg1 - min value of shmmax in MB (see: /etc/sysctl.conf)
check_shmmax() {
    set_value_mb=${1:-40} #default is 32MB + headroom = 40MB
    let set_value_bytes=$((set_value_mb*1024*1024))
    cur_value_bytes=$(sysctl -q kernel.shmmax | tr -s "=" | cut -d= -f2)
    let cur_value_bytes=${cur_value_bytes## }
    
    if ((cur_value_bytes < set_value_bytes)); then
        echo "Current system shared mem value too low [$cur_value_bytes bytes] changing to [$set_value_bytes bytes]"
        sysctl -w kernel.shmmax=${set_value_bytes}
        echo "kernel.shmmax = ${set_value_bytes}" >> /etc/sysctl.conf
    fi
}

#This function is for repeatedly running a function until it returns
#true and/or the number of iterations have been reached.  The format of
#the args for this call are as follows:
#
# pcheck <num_of_iterations> <wait_time_in_seconds> <return_on_true> -- [function name] <args...>
# The default operation is the run the function once a scecond for 5 seconds or until it returns true
# The default value of iterations is 5
# The default value of wait time is  1 (second)
# The default value of return on true is 1 (no more iterations after function/command succeeds)
# the "--" is a literal argument that MUST precede the function or command you wish to call
#
# Ex:
# Run a function or command foo 3x waiting 2 seconds between and returning after function/command success
# pcheck 3 2 1 -- foo arg1 arg2
# Run a function or command foo using defaults
# pcheck -- foo arg1 arg2
#
# Returns the value from the final execution of the function or command.
pcheck() {
    (($DEBUG)) && echo "pcheck $@"
    #initial default values
    local iterations=5
    local wait_time=1
    local return_on_true=1
    local task_function=""

    local_vars=(iterations wait_time return_on_true)
    local i=0
    while [[ -n "$1" ]]; do
        if [ "$1" == "--" ] ; then
            shift
            task_function=$1
            shift
            break
        fi
        eval local ${local_vars[((i++))]}=$1
        shift
    done
    (($DEBUG)) && echo "iterations = ${iterations}"
    (($DEBUG)) && echo "wait_time = ${wait_time}"
    (($DEBUG)) && echo "return_on_true = ${return_on_true}"
    (($DEBUG)) && echo "task_function = ${task_function}"
    (($DEBUG)) && echo "args = [$@]"

    local ret=1
    while [[ $iterations > 0 ]]; do
        echo -n "."
        eval ${task_function} $@
        ret=$?
        ((return_on_true)) && [ $ret == 0 ] && break
        ((iterations != 1)) && sleep ${wait_time}
        ((iterations--))
    done
    [ $ret == 0 ] && printf "\n${task_function} [OK]\n" || printf "\n${task_function} [FAIL]\n"
    return $ret
}

uninstall() {
    local doit="N"
    read -p "Are you sure you want to uninstall? [y/N]: " doit
    if [ "$doit" = "y" ] || [ "$doit" = "Y" ]; then

        doit="N"
        if [ -e $postgress_install_dir ]; then 
            read -p "remove postgress? ($postgress_install_dir) [y/N]: " doit
            if [ "doit" = "Y" ] || [ "$doit" = "y" ]; then
                echo "removing $postgress_install_dir"
                rm -rf ${postgress_install_dir}
                [ $? != 0 ] && echo "ERROR: Unable to remove ${postgress_install_dir}"
            fi
        fi
        
        doit="N"
        if [ -e $cdat_home ]; then
            read -p "remove cdat? ($cdat_home) [y/N]: " doit
            if [ "doit" = "Y" ] || [ "$doit" = "y" ]; then
                echo "removing $cdat_home"
                rm -rf ${cdat_home}
                [ $? != 0 ] && echo "ERROR: Unable to remove ${cdat_home}"
            fi
        fi

        doit="N"
        if [ -e ${HOME}/.esgcet ]; then
            read -p "remove .esgcet files? (${HOME}/.esgcet) [y/N]: " doit
            if [ "doit" = "Y" ] || [ "$doit" = "y" ]; then
                echo "removing ${HOME}/.esgcet"
                rm -rf ${HOME}/.esgcet
                [ $? != 0 ] && echo "ERROR: Unable to remove ${HOME}/.esgcet}"
            fi
        fi

        doit="N"
        if [ -e ${node_app_home} ]; then
            read -p "remove ESG Node web service? (${tomcat_install_dir}/webapps/${node_app_context_root}) [y/N]: " doit
            if [ "doit" = "Y" ] || [ "$doit" = "y" ]; then
                echo "removing ${tomcat_install_dir}/webapps/${node_app_context_root}"
                rm -rf ${tomcat_install_dir}/webapps/${node_app_context_root}
                [ $? != 0 ] && echo "ERROR: Unable to remove ${tomcat_install_dir}/webapps/${node_app_context_root}"
            fi
        fi 

        doit="N"
        if [ -e ${tomcat_install_dir}/webapps/thredds ]; then
            read -p "remove Thredds web service? (${tomcat_install_dir}/webapps/thredds) [y/N]: " doit
            if [ "doit" = "Y" ] || [ "$doit" = "y" ]; then
                echo "removing ${tomcat_install_dir}/webapps/thredds"
                rm -rf ${tomcat_install_dir}/webapps/thredds
                [ $? != 0 ] && echo "ERROR: Unable to remove ${tomcat_install_dir}/webapps/thredds"
            fi
        fi 

        doit="N"
        if [ -e $tomcat_install_dir ]; then
            read -p "remove apache tomcat? ($tomcat_install_dir) [y/N]: " doit
            if [ "doit" = "Y" ] || [ "$doit" = "y" ]; then
                echo "removing $tomcat_install_dir"
                rm -ri $tomcat_install_dir
                [ $? != 0 ] && echo "ERROR: Unable to remove ${tomcat_install_dir}"
            fi
        fi
        
        doit="N"
        if [ -e ${globus_location}/esg_${progname}_installed ] && (( ! no_globus )); then
            read -p "remove globus certs? ($globus_location) [y/N]: " doit
            if [ "doit" = "Y" ] || [ "$doit" = "y" ]; then
                echo "removing $globus_location"
                [ -n ${globus_location} ] && [ -e ${globus_location} ] && rm -rf ${globus_location}
                [ $? != 0 ] && echo "ERROR: Unable to remove ${globus_location}"
            fi
        fi
    fi
    exit 0
}

set_classpath() {
    local CP="."
    CP=${CP}:${node_app_home}/WEB-INF/classes
    
    for i in $( ls ${node_app_home}/WEB-INF/lib ); do
        CP=${CP}:${node_app_home}/WEB-INF/lib/"$i"
    done
    
    CP=${CP}:${CATALINA_HOME}/lib/servlet-api.jar
    CLASSPATH=${CP}
    export CLASSPATH
    return 0;
}

#-------------------------------
# Process checking utility functions
#-------------------------------

#This function "succeeds" (is true; returns 0)  if there *are* running processes found running
check_postgress_process() {
    local val=$(ps -elf | grep postgres | grep -v grep | awk ' END { print NR }')
    [ $(($val > 0 )) == 1 ] && echo "Postgres process is running..." && return 0
    return 1
}

#This function "succeeds" (is true; returns 0)  if there *are* running processes found running
check_tomcat_process() {
    if [ -f ${tomcat_install_dir}/conf/server.xml ]; then
        local ports=$(sed -n 's/.*Connector.*port="\([0-9]*\)".*/\1/p' ${tomcat_install_dir}/conf/server.xml | xargs | sed 's/[ ]/|/gp' | uniq)
        local procs="$(lsof -Pni | egrep '\*:('${ports}')\s+' | awk '{print $1}' | uniq | xargs)"
        [ -z "${procs}" ] && return 1 #No process running on ports
        if [ jsvc = "${procs}" ]; then
            echo "Tomcat (jsvc) process is running... " && return 0
        else
            echo " WARNING: There is another process running on expected Tomcat (jsvc) ports!!!! [${procs}] ?? "
            return 3
        fi
    else
        echo " Warning Cannot find ${tomcat_install_dir}/conf/server.xml file!"
        echo " Using alternative method for checking on tomcat process..."
        local val=$(ps -elf | grep jsvc | grep -v grep | awk ' END { print NR }')
        [ $(($val > 0 )) == 1 ] && echo "Tomcat (jsvc) process is running..." && return 0
        echo " No Tomcat (jsvc) processes detected"
        return 2
    fi
}

#-------------------------------
# Version Checking Utility Functions
#-------------------------------

#--------------------------------------------------------------------------
# Donated function from Estanislao (thanks!)
# To do a bit more robust version checking... See the "check_version" function 
#-----
compare_versions_() {
    (($DEBUG)) && echo "Comparing versions: $@"
    OLDIFS=$IFS
    IFS=".-_/@+#"
    (($DEBUG)) && echo $@
    count1=0
    for v1 in $1; do
        (($DEBUG2)) && echo v1=$v1
        count2=0
        for v2 in $3; do
            (($DEBUG2)) && echo "v2=$v2" && echo "[[ \$count2=$count2 == \$count1=$count1 ]]"
            if [[ $count2 == $count1 && $v1 != $v2 ]]; then
                #if same so keep going... so break inner for loop
                (($DEBUG2)) && echo "[[ \$v1=$v1 == \$v2=$v2 ]]"
                [[ $v1 == $v2 ]] && break

                #ok, no match here we resolve it: compare v1 and v2
                (($DEBUG2)) && echo "[[ $v1 $2 $v2 ]]"
                #don't forget to set it back!
                IFS=$OLDIFS
                
                eval "[[ $v1 $2 $v2 ]]"
                return $?
            fi
            : $((++count2)) 
        done
        #remove last count (which doesn't count :-)
        : $((--count2))
        : $((++count1))
    done
    #remove last count (which doesn't count :-)
    : $((--count1))
    
    #don't mess with this...
    IFS=$OLDIFS
    
    (($DEBUG)) && echo "compare last one again in case we have two equal versions"
    eval "[[ $v1 $2 $v2 ]]"
    ret=$?
    
    (($DEBUG)) && echo "equality was allowed, check passed"
    [[ $ret == 0 ]] && return 0
    
    
    #if here the strings were equal or $1 is longer than $2 (and therefore "greater")
    (($DEBUG)) && echo "[[ count1=$count1 > count2=$count2 ]]"
    if [[ $count1 = $count2 ]]; then
        (($DEBUG)) && echo "they were equal, but equality wasn't expected (ret 1)"
        return 1
    else
        (($DEBUG)) && echo "the longest is the gretest. Compare length.i"
        eval "[[ $count1 $2 $count2 ]]"
        return $?
    fi
}

#------
# "Private Utility/Helper method for the check_version[^_] function to follow.
# Does some arge scrubbing etc.
#------
# the first non numeric field breaks comparison and is treated as a special field
# which is equal to any other non numneric one.
# only numeric fields before non numeric ones are considered
# so 1.1.a == 1.1.b and 1.1_B203 == 1.1_B204 and 1.b.1 == 1.c.4 (!!)
# but and 1.2.a > 1.1.y and 1.1.a > 1.1 (!!)
check_version_helper() {
    (($DEBUG)) && echo "in check_version_helper $@"
    #only one parameter, probably a string, expand it
    [[ $# == 1 ]] && set -- $1
    (($DEBUG)) && echo "\$1=$1, \$2=$2, \$3=$3"
    
    #check we have what we need
    if [[  -z $1 || -z $2  || -z $3 ]]; then 
        [[ $verbose ]] && usage
        return 255 
    fi

    #transform operators in arithmetic ones (if not already)
    case $2 in
        '>') op="-gt" ;;
        '>=') op="-ge" ;;
        '<') op="-lt" ;;
        '<=') op="-le" ;;
        =|==) op="-eq" ;;
!=|'<>') op="-ne" ;;
*) op=$2
esac

    #we only need three params for this function
compare_versions_ "${1}" "$op" "${3}"
local ret=$?
(($DEBUG)) && echo "compare_versions from check_version_ returns $ret"
return $ret
}

#The "Public" function that should be called.  Delegates to the helper functions (the two above)
#Makes the calls to fetch the version information about the passed in executable
# Returns 0 if everything is up to date (version-wise)
# Returns 1 if the current version is older than the required version
# Returns 2 if could not find executible at all on the system
check_version() {
    (($DEBUG)) && echo "check_version $@"
    [ -z $2 ] && return 0
    (($DEBUG)) && echo $2
    local target_version=$(echo $2 | perl -ne '/(\d+\.+\d*\.*\d*[.-_@+#]*\d*).*/, print "$1 "' | tr -d "\"" | cut -d " " -f1,1)
    (($DEBUG)) && echo "target_version = [$target_version]"

    $1 --version >& /tmp/f || $1 -version >& /tmp/f
    [ $? != 0 ] && echo && echo "Oops, $1 command not found" && return 2
    current_version=$(cat /tmp/f 2>&1 | perl -ne '/(\d+\.+\d*\.*\d*[.-_@+#]*\d*).*/, print "$1 "' | tr -d "\""  | cut -d " " -f1,1)
    (($DEBUG)) && echo "current_version = [$current_version]"
    
    (($DEBUG)) && echo "Calling helper, check_version_helper ${current_version} >= ${target_version}"
    check_version_helper "${current_version}" ">=" "${target_version}" # note: bug found (needed to quote the operation ">=")
    local ret=$?
    (($DEBUG)) && echo "The return value from the call to helper function check_version_ is $ret"
    [ $ret == 0 ] && return 0

    printf "\nSorry, the detected version of $1 [${current_version}] is older than required minimum version [$2] \n"
    cat /tmp/f
    rm /tmp/f >& /dev/null
    return 1
}

#For python module version checking
#Looking for __version__ var
check_module_version() {
    local module_name=$1
    local target_version=$2
    
    local current_version=$(${cdat_home}/bin/python -c "import ${module_name}; print ${module_name}.__version__" 2> /dev/null)
    [ $? != 0 ] && echo " WARNING:(2) Could not detect version of ${module_name}" && return 2
    [ -z "${current_version}" ] && echo " WARNING:(1) Could not detect version of ${module_name}" && return 3

    (($DEBUG)) && echo " calling helper, check_version_helper ${current_version} >= ${target_version}"
    check_version_helper "${current_version}" ">=" "${target_version}" # note: bug found (needed to quote the operation ">=")
    local ret=$?
    (($DEBUG)) && echo " The return value from the call to helper function check_version_ is $ret"
    [ $ret == 0 ] && return 0

    printf "\nSorry, the detected version of $1 [${current_version}] is older than required minimum version [${target_version}] \n"
    return 1
}

check_webapp_version() {
    local webapp_name=$1
    local target_version=$2
    local version_property=${3:-"Version"}

    [ ! -d "${tomcat_install_dir}/webapps/${webapp_name}" ] && echo " Web Application \"${webapp_name}\" is not present or cannot be detected!" && return 2

    local current_version=$(sed -n '/^'${version_property}':[ ]*\(.*\)/p' ${tomcat_install_dir}/webapps/${webapp_name}/META-INF/MANIFEST.MF | awk '{print $2}' | xargs 2> /dev/null)
    [ $? != 0 ] && echo " WARNING:(2) Could not detect version of ${webapp_name}" && return 3
    [ -z "${current_version}" ] && echo " WARNING:(1) Could not detect version of ${webapp_name}" && return 4

    (($DEBUG)) && echo " calling helper, check_version_helper ${current_version} >= ${target_version}"
    check_version_helper "${current_version}" ">=" "${target_version}" # note: bug found (needed to quote the operation ">=")
    local ret=$?
    (($DEBUG)) && echo " The return value from the call to helper function check_version_ is $ret"
    [ $ret == 0 ] && return 0

    printf "\nSorry, the detected version of $1 [${current_version}] is older than required minimum version [${target_version}] \n"
    return 1
}

#0ne-off version checking mechanism for applications where version number is in the name of the directory
#of the form "app_dir-<version_num>"
check_app_version() {
    local app_dir=$1
    local target_version=$2

    local current_version=$(readlink -f ${tomcat_install_dir} | sed -ne 's/.*-\(.*\)$/\1/p')
    [ $? != 0 ] && echo " WARNING:(2) Could not detect version of ${app_dir##*/}" && return 2
    [ -z "${current_version}" ] && echo " WARNING:(1) Could not detect version of ${app_dir##*/}" && return 3

    (($DEBUG)) && echo " calling helper, check_version_helper ${current_version} >= ${target_version}"
    check_version_helper "${current_version}" ">=" "${target_version}" # note: bug found (needed to quote the operation ">=")
    local ret=$?
    (($DEBUG)) && echo " The return value from the call to helper function check_version_ is $ret"
    [ $ret == 0 ] && return 0

    printf "\nSorry, the detected version of ${app_dir##*/} [${current_version}] is older than required minimum version [${target_version}] \n"
    return 1
}

#Provide your own command for fetching current version
check_version_with() {
    local app_name=$1
    local target_version=$2
    local version_command=${3:-"${app_name} --version"}

    local current_version=$(${version_command})
    [ $? != 0 ] && echo " WARNING:(2) Could not detect version of ${app_name##*/}" && return 3

    (($DEBUG)) && echo " calling helper, check_version_helper ${current_version} >= ${target_version}"
    check_version_helper "${current_version}" ">=" "${target_version}" # note: bug found (needed to quote the operation ">=")
    local ret=$?
    (($DEBUG)) && echo " The return value from the call to helper function check_version_ is $ret"
    [ $ret == 0 ] && return 0

    printf "\nSorry, the detected version of ${app_name##*/} [${current_version}] is older than required minimum version [${target_version}] \n"
    return 1
}

# arg 1 filter name
# arg 2 webapp name
#check_for_filter() {
#
#}

#--------------------------------------------------------------------------


checked_done() {
    if (($1)); then
        echo ""
        echo "Sorry..."
        echo "This action did not complete successfully"
        echo "Please re-run this task until successful before continuing further"
        echo ""
        exit 1
    fi
    return 0
}

# Does an md5 check between local and remote resource
# returns 0 (success) iff there is no match and thus indicating that
# an update is available.
# USAGE: checked_for_update [file] http://www.foo.com/file
#
check_for_update() {
    local local_file
    local remote_file
    if (( $# == 1 )); then
        remote_file=${1}
        local_file=$(readlink -f ${1##*/})
    elif (( $# == 2 )); then
        local_file=${1}
        remote_file=${2}
    else
        echo "function \"checked_for_update\":  Called with incorrect number of args! (fatal)"
        exit 1
    fi                      
    
    [ ! -e ${local_file} ] && echo " Hmmm... Could not find local file ${local_file}" && return 0
   #[ ! -x ${local_file} ] && echo " Hmmm... local file ${local_file} not executible" && chmod 755 ${local_file}
    diff <(md5sum ${local_file} | tr -s " " | cut -d " " -f 1) <(curl -s -L --insecure ${remote_file}.md5 | tr -s " " | cut -d " " -f 1) >& /dev/null
    [ $? != 0 ] && echo " Update Available @ ${remote_file}" && return 0
    echo " ==> ${local_file} is up to date"
    return 1
}

# If an update is available then pull it down... then check the md5 sums again!
#
#  Yes, this results in 3 network calls to pull down a file, but it
#  saves total bandwidth and it also allows the updating from the
#  network process to be cronttab-able while parsimonious with
#  resources.  It is also very good practice to make sure that code
#  being executed is the RIGHT code!
#
# NOTE: Has multiple return values test for (( $? > 1 )) when looking or errors
#       A return value of 1 only means that the file is up-to-date and there
#       Is no reason to fetch it.
#
# USAGE: checked_get [file] http://www.foo.com/file
#
checked_get() {
    check_for_update $@
    [ $? != 0 ] && return 1

    local local_file
    local remote_file
    if (( $# == 1 )); then
        remote_file=${1}
        local_file=${1##*/}
    elif (( $# == 2 )); then
        local_file=${1}
        remote_file=${2}
    else
        echo "function \"checked_get\":  Called with incorrect number of args! (fatal)"
        exit 1
    fi                      
    
    if [ -e ${local_file} ]; then
        cp -v ${local_file} ${local_file}.bak
        chmod 600 ${local_file}.bak
    fi
    wget --no-check-certificate -O ${local_file} ${remote_file}
    [ $? != 0 ] && echo " ERROR: Problem pulling down [${remote_file##*/}] from esg distribution site" && return 2
    diff <(md5sum ${local_file} | tr -s " " | cut -d " " -f 1) <(curl -s -L --insecure ${remote_file}.md5 | tr -s " " | cut -d " " -f 1) >& /dev/null
    [ $? != 0 ] && echo " WARNING: Could not verify file! ${local_file}" && return 3
    echo "[VERIFIED]"
    return 0
}

#arg1 - a filesystem path
backup() {
    [ -z "$1" ] && echo "backup - source must be provided as arg1" && return 1
    [ -d "$1" ] && echo "backup - must take a directory! $1 not a directory" && return 1
    local source="$(readlink -f $1)"
    echo "Backup - Creating a backup archive of ${source}"
    pushd ${source%/*} >& /dev/null
    mkdir -p ${esg_backup_dir} >& /dev/null
    local backup_filename=$(readlink -f ${esg_backup_dir})/${source##*/}.$(date ${date_format}).tgz
    tar czf ${backup_filename} ${source##*/}
    [ $? != 0 ] && echo " ERROR: Problem with creating backup archive: ${backup_filename}" && popd >& /dev/null && return 1
    if [ -e ${backup_filename} ]; then 
        echo "Created backup: ${backup_filename}" 
    else
        echo "Could not locate backup file ${backup_filename}"
        popd >& /dev/null
        return 1
    fi
    

    #-------------
    #keep only the last num_backups_to_keep files
    num_backups_to_keep=${num_backups_to_keep:-7}
    pushd ${esg_backup_dir} >& /dev/null
    files=(`ls -t | grep ${source##*/}.\*.tgz | tail -n +$((${num_backups_to_keep}+1)) | xargs`)
    if (( ${#files[@]} > 0 )); then
        echo "Tidying up a bit..."
        echo "${#files[@]} old backup files to remove: ${files[@]}"
        rm -v ${files[@]}
    fi
    popd >& /dev/null
    #-------------

    popd >& /dev/null
    return 0

    
}

backup_db() {
    mkdir -p ${esg_backup_dir}
    pushd ${esg_backup_dir} >& /dev/null
    
    echo -n "Backing up database: ${node_db_name} to  ${node_db_name}_backup_$(date ${date_format}).sql"
    pg_dump -U ${postgress_user} ${node_db_name} > ${node_db_name}_backup_$(date ${date_format}).sql
    [ $? == 0 ] && echo " [OK] " || echo " [FAIL] "
    echo -n "Backing up security schema to ${node_db_name}_security_backup_$(date ${date_format}).sql"
    pg_dump -U ${postgress_user} --schema security ${node_db_name} > ${node_db_name}_security_backup_$(date ${date_format}).sql
    [ $? == 0 ] && echo " [OK] " || echo " [FAIL] "
    
    popd >& /dev/null
    return 0
}

#Replace a pattern inside the target file with the contents of the input file
insert_file_at_pattern() {
    local target_file=$1
    local input_file=$2
    local pattern=$3

    echo "Inserting into ${target_file} <- ${input_file} at pattern ${pattern}"

    python -c "infile = '${target_file}';filterfile = '${input_file}';pattern='${pattern}';f=open(infile);s=f.read();f.close();f=open(filterfile);filter = f.read();f.close();s=s.replace(pattern,filter);f=open(infile,'w');f.write(s);f.close()"
    ret=$?
    [ $ret != 0 ] && echo "Problem in function insert_file_at_pattern in $0"
    return ${ret}
}

# Environment variable files of the form
# Ex: export FOOBAR=some_value
# Will have duplcate keys removed such that the
# last entry of that variable is the only one present
# in the final output.
# arg 1 - The environment file to dedup.
dedup() {
    local infile=${1:-${envfile}}
    [ ! -w "${infile}" ] && echo "WARNING: dedup() - unable to write to ${infile}" && return 1
    local tmp=$(tac ${infile} | awk 'BEGIN {FS="[ =]"} !($2 in a) {a[$2];print $0}' | sort -k2,2)
    echo "$tmp" > ${infile}
}

#"private" function
_verify() {
    echo "diff <(md5sum ${0} | tr -s " " | cut -d " " -f 1) <(curl ${1}/esg-node/${0##*/}.md5 | tr -s " " | cut -d " " -f 1) >& /dev/null "
    diff <(md5sum ${0} | tr -s " " | cut -d " " -f 1) <(curl -s -L --insecure ${1}/esg-node/${0##*/}.md5 | tr -s " " | cut -d " " -f 1) >& /dev/null
    [ $? != 0 ] && return 3
    echo "[VERIFIED]"
    return 0
}

self_verify() {
    _verify 'http://198.128.245.140/dist' >& /dev/null 
    if (( $? == 3 )); then 
        printf "WARNING: $0 could not be verified!! \n(This file, ${0}, may have been tampered with or there is a newer version posted at the distribution server.\nPlease update this script.)\n\n"
        
        local choice="x"
        if [ "$#" == 1 ]; then
            (($DEBUG)) && echo "Operation $1 was chosen"
            choice=$1
        else
            local input=""
            read -t $((1*60)) -p "Do you wish to Update and exit [u], continue anyway [c] or simply exit [x]? [u/c/X]: " input
            [ -n "${input}" ] && choice=${input}
            unset input
        fi
        
        if [ "$choice" = "C" ] || [ "$choice" = "c" ] || [ -z "$choice" ]; then
            echo "Continuing..."
            echo 
            return 0
        elif [ "$choice" = "U" ] || [ "$choice" = "u" ]; then
            echo "Updating local script with script from distribution server..."
            /usr/local/bin/esg-update node
            echo "Please re-run this updated script $0"
            echo
            exit 1
        else
            echo "Exiting..."
            echo
            exit 1
        fi
    else
        return 0
    fi
    return 0
}

#Helper method for reading the last state of node type config from config dir file "config_type"
#Every successful, explicit call to --type|-t gets recorded in the "config_type" file
#If the configuration type is not explicity set the value is read from this file.
read_sel() {
    ((DEBUG)) && echo "read_sel(${sel})"
    local let mysel=${sel}
    ((DEBUG)) && echo "mysel = ${mysel}"

    #If mysel (our private copy of sel) has not bits in the type bits range then read the config_type file
    #and set us to whatever value we currently add plus that one.  In the case of installation or testing
    #those values are below the range so they shoudl not be looked at for type selection though they may be
    #set.  However whatever we have for the type selection should be added to them for compound selection.
    if (( (mysel < MIN_BIT) || (mysel > MAX_BIT) )); then
        ((DEBUG)) && echo "Out of Range ${mysel} < ${MIN_BIT} || ${mysel} > ${MAX_BIT}"
        local last_config_type=$(cat ${esg_config_type_file} 2> /dev/null)
        ((mysel+= ${last_config_type:-0}))
        ((DEBUG)) && echo "mysel is now: ${mysel}"
    fi
    ((mysel == 0)) && \
        printf "ERROR: No node type selected nor available! \n Consult usage with --help flag... look for the \"--type\" flag \n(must come BEFORE \"[start|stop|restart|update]\" args)\n\n"
    
    ((DEBUG)) && echo "Setting sel [${sel}] to mysel [${mysel}]"
    sel=${mysel}
}

#Write the node type numeric value to file
#(Yes... gratuitous error and bounds checking)
set_sel() {
    local new_sel=${1}
    ((DEBUG)) && echo "new_sel = $new_sel"
    local type_bits=0
    local hit_bits=0
    
    #valididty check for type... in range power of 2
    #MIN and MAX BIT range... if so then valid and an be written down.
    if ((new_sel > $MAX_BIT || new_sel < $MIN_BIT)); then
        ((DEBUG)) && echo "WARNING: Selection [$1] is out of range $MIN_BIT - $MAX_BIT"
    fi

    #Check if the new sel has any bits turned on in the range of our type bits
    for ((type_bit=$MIN_BIT;type_bit<=$MAX_BIT;type_bit*=2)) ; do
        (( (new_sel & type_bit) != 0 )) && ((hit_bits+=type_bit))
    done


    ((DEBUG)) && echo "[hit_bits = $hit_bits] =? [new_sel = $new_sel]"

    if((hit_bits)); then
        echo "${hit_bits}" > ${esg_config_type_file}
        ((DEBUG)) && cat ${esg_config_type_file}
    fi
}

show_svc_list() {
    id | grep root >& /dev/null
    [ $? != 0 ] && echo "(display of node process list limited to root)" && return 0
    echo
    echo "---------------------------"
    echo "Running Node Services... "; ((sel != 0)) && show_type || echo ""
    echo "---------------------------"
    lsof -i |egrep  'postgres|jsvc|globus-gr|java|myproxy'
    echo "---------------------------"
    echo
    return 0
}

#-------------------------------
# ESG Node Life Cycle Functions (start/stop/status)
#-------------------------------

#Starts the esg node
start() {
    local let sel=${1:-${sel:-0}}
    init
    ((DEBUG)) && echo "starting services... ($1)"
    read_sel
    
    [ $((sel & ALL_BIT)) == 0 ] && echo "Cannot Start: No Node Type Specified! (See --help for info on the --type|-t option)  :-|" && exit 1
    
    echo "starting services... ($sel)"
    /etc/init.d/ntpd start
    
    [ $((sel & ALL_BIT)) != 0 ] && start_postgress
    [ $((sel & ALL_BIT)) != 0 ] && start_tomcat

    (( ! no_globus )) && [ $((sel & DATA_BIT+IDP_BIT)) != 0 ] && start_globus ${sel} ${gridftp_config_args}
    [ $((sel & INDEX_BIT)) != 0 ] && source ${scripts_dir}/esg-search >& /dev/null && start_search_services

    sleep 3
    show_svc_list

    set_sel "${sel}"
    echo
}

#Stops the esg node
stop() {
    local sel=${1:-${sel:-$ALL_BIT}}
    init
    read_sel
    source ${scripts_dir}/esg-search >& /dev/null && stop_search_services
    stop_globus $(( sel == 0 ? ALL_BIT : sel)) ${gridftp_config_args}
    stop_tomcat 
    stop_postgress 
    show_svc_list
}

#Displays the status of the node...
status() {
    #TODO conditionally reflect the status of globus (gridftp) process
    init
    read_sel
    local ret=1
    if check_postgress_process && check_tomcat_process; then
        echo
        echo "Node Running... (${sel})"
        ret=0
    else
        echo
        echo "Stopped: No running processes detected"
        ret=1
    fi
    #This is here for sanity checking...
    show_svc_list
    return ${ret}
}


############################################
# Main
############################################
info() {

    printf " 

     The goal of this script is to automate as many tasks as possible
     regarding the installation of the software stack that is the Data
     Node.  A software stack is a collection of tools that work in
     concert to perform a particular task or set of tasks that are
     semantically united.  Essentially, the gestalt is the ESG
     DataNode. The software stack is comprised of; Tomcat, Thredds,
     CDAT & CDMS, PostgreSQL, MyProxy and RedHat/CentOS. Through the
     installation process there are different accounts that are
     created that facilitate the communication between these separate
     software entities.  These credentials are internal to the stack.
     It is recommended that you use the defaults provided throughout
     this installation.  The security impact with regards to the
     visibility and accessibility of the constituent components of the
     stack depends on other factors to be addressed by your
     organization.

     Please be sure that you have gotten your Gateway (IdP)
     credentials from your configured Gateway.

     The primary/central Gateway for ESGF is:
     http://pcmdi3.llnl.gov/esgcet/home.htm -> \"create account\"

     This is required for publication.

     Data Node:
               ---------
               |Tomcat   |
               |-Node Mgr|
               |-Thredds |
               |-ORP     |
               |---------|
               |CDAT/CDMS|
               |---------|
               |Postgres |
               |---------|
               | MyProxy |  <===(HTTPS)===> [Gateway(s)]*
               |---------|
               | GridFTP |  <=============> [End User(s)]*
               >---------<
               | CentOS  |
               |(Virtual)|
               | Machine |
               |---------|
               ---------

     -ESG \n\n" | more 
    
}

usage() {
    printf "
usage:
(as root)
${progname} ([--<directive>] | [start] | [stop] | [status] [restart]
        --prefix      - specify the top level directory for this entire installation's \"external\" tools
                        (default:/usr/local - currently:$install_prefix)
        --workdir     - specify the directory used by the installation to download and build esg artifacts for installation
                        (default:~/workbench/esg - currently:$workdir)
        --install     - goes through the installation process
                         will automatically start up data node services
        --verify      - runs the test code to verify installation
        --write-env   - writes the necessary env vars to file ${envfile}
        --version     - indicates the version of this script
        --check       - checks if this script is the most up-to-date posted <u|C|x> (Update|Continue|eXit)
        --clear       - removes the file holding the enironment state of last install
        --test-pub    - performs the publication test directly (same publication called in last step of install)
        --info        - provides a brief explaination of the DataNode
        --upgrade|--update - upgrades/updates the node manager

        -------------------------------
        Configuration Selection
        -------------------------------
        --type | -t <data &| index &| idp> - Select type of node: \"data node\", \"index node\" and/or \"identity provider node\" (\"data\" is default)
        --set-type  <data &| index &| idp> - Sets the type value to be used at next start up
        --get-type - returns the last stored type code value of the last run node configuration (data=4 +| index=8 +| idp=16)

        -------------------------------
        Globus Tool Management
        -------------------------------
        --no-globus   - will not perform any operations affecting globus tools (for those with existing globus setups)
        --gridftp-config - [ with-bdm-config | bdm-config-only ] without this arg uses default end-user config only
        --myproxy - [gen-self-cert] <dir> | [regen-simpleca] [fetch-certs|gen-self-cert|keep-certs] | [install|update]

        -------------------------------
        Key Management Flags:
        -------------------------------
        --register    - connects to desired node, fetches and stores their certificate to enable ingress SSL connections
        --generate-ssl-key-and-csr - generate new key and cert request files <key file> <cert file> [<dn>]
                                     (The 'dn' value is of the form - Ex:'/O=ESG/OU=ESG-DATA-NODE/CN=<fqdn>')
        --install-keypair - takes as input private key and public cert files and installs them. <key> <cert> [<keystore> <alias> <password>]
        --fetch-esg-certs - fetches and installs all current public esg federation certificates (used by globus)
        --rebuild-truststore - converts globus' (public) ca certificates into a truststore.
        --add-my-cert-to-truststore - adds public cert from keystore to truststore: <keystore password>
        --clear-certs - removes the user-level public certificates' directory (used by myproxy)

        (deprecated) --install-signed-cert - installs signed host certificate into keystore and truststore <signed PEM file>
        (deprecated) --export-keys-to-globus  - exports keystore certificates to globus host{cert,key}.pem files.

        -------------------------------
        Node Life Cycle Flags:
        -------------------------------
        start   - start the node's services
        stop    - stops the node's services
        status  - status on node's services
        restart - restarts the node's services (calls stop then start :-/)
        update  - update's the node's software stack to prescribed versions
            (notice, no \"--\" to make rc friendly also chkconfig-able ;-)

        -------------------------------
        To add this script to the linux boot sequence: (as root)
        > cd /etc/init.d
        > cp ${install_prefix}/bin/esg-node
        > chkconfig --add esg-node
        > chkconfig --list esg-node
        -------------------------------

    
      \"stop\" | \"start\" | \"status\" are meant to be run independent of other flags (and put LAST if other flags are used)
      \"--install\" may be used with \"--verify\" but neither are not intended for use
      with stop or start or status
      Ex:
         ${progname} --install OR
         ${progname} --verify OR
         ${progname} --install --verify  OR
         ${progname} --write-env OR
         ${progname} --version OR
         ${progname} --clear OR
         ${progname} --test-pub OR
         ${progname} --info OR
         ${progname} --register [gateway.host.address] ([truststore passwd])
         ${progname} --gridftp-config [ with-bdm-config | bdm-config-only ]
         ${progname} start OR
         ${progname} --gridftp-config [ with-bdm-config | bdm-config-only ] start OR
         ${progname} stop  OR
         ${progname} status OR
    
      NOTE:

      *You must be root or effectively root to run this program,
      *prefixing the command with sudo will not allow the use of
      *needed environment variables!!!! If you must use sudo, do so
      *only to become root proper then source your user's .[bash]rc
      *file so that root has it's envronment set accordingly!  Or you
      *can more simply become root using sudo's \"-s\" flag.  After a
      *full install there will be a file created ($envfile) that has
      *the basic environment vars that were used and set during the
      *installation - this should be sourced by users of this
      *application stack.

      --------------
      Typical usage:
      --------------

      Installation : esg-node --install --verify
          (submit csr and get back returned cert)
      Credentials  : esg-node --install-keypair <key> <cert>
      Test Publish : esg-node --test-pub
      Update Certs : esg-node [--force] --rebuild-truststore
      Life Cycle   : esg-node [start|stop|status|restart|update]

    " | more
    exit 0
}

done_remark() {
    echo ""
    echo "Finished!..."
    echo "In order to see if this data node has been installed properly you may direct your browser to:"
    echo "http://${my_ip_address}/${node_app_context_root}"
    echo "http://${my_ip_address}/thredds"
    echo "http://${my_ip_address}/OpenidRelyingParty"
    echo 
    echo "To see the published test, go your specified gateway: [${ESG_GATEWAY_NAME}]"
    echo "http://${ESG_GATEWAY_SVC_ROOT}"
    echo "and browse to \"Test Project\" -> pcmdi.${esg_root_id}.test.mytest"
    echo ""
}

#---------------
# s'all about the bits... :-)
#---------------
INSTALL_BIT=1
TEST_BIT=2
DATA_BIT=4
INDEX_BIT=8
IDP_BIT=16
WRITE_ENV_BIT=32

#NOTE: remember to adjust (below) when adding new bits!!
MIN_BIT=4
MAX_BIT=32
ALL_BIT=$((DATA_BIT+INDEX_BIT+IDP_BIT))
#---------------

show_type() {
    [ $((sel & DATA_BIT)) != 0 ] && resolved_to+="data "
    [ $((sel & INDEX_BIT)) != 0 ] && resolved_to+="index "
    [ $((sel & IDP_BIT)) != 0 ] && resolved_to+="idp "
    echo "node type: [ ${resolved_to}] (${sel}) "
}

main() {

    let sel=0
    local selection_string
    while [ -n "$1" ]; do
    #echo "arg ${i} = $1"
        local unshift=0
        case $1 in
            --install | -i)
                ((DEBUG)) && echo "INSTALL SERVICES"
                (( (sel & INSTALL_BIT) == 0 )) && ((sel+=INSTALL_BIT))
                ;;
            --verify | --test)
                ((DEBUG)) && echo "VERIFY SERVICES"
                (( (sel & TEST_BIT) == 0 )) && ((sel+=TEST_BIT))
                ((DEBUG)) && echo "sel = $sel "
                ;;
            --type | -t)
                #TODO: look for next arg if data node or if index node set the selection bit accordingly
                #This also means that I can nott use 1 for basic install will have to use 1 for prerequisite
                #and then another bit for data node vs index node
                local tvalue
                shift
                until [ $(echo $1 | egrep '^\s*--') ] || [ -z "$1" ] || [ "$1" = "stop" ] || [ "$1" = "start" ] || [ "$1" = "status" ] || [ "$1" = "restart" ] || [ "$1" = "update" ]; do
                    tvalue=$(echo "$1" | tr 'A-Z' 'a-z')
                    #turn on the proper bit when string is detected
                    [ "all"   = "${tvalue}" ] && sel=$ALL_BIT && selection_string="all " && shift && break
                    [ "data"  = "${tvalue}" ] && (( (sel & DATA_BIT) == 0 )) && ((sel+=DATA_BIT)) && selection_string+="${tvalue} "
                    [ "index" = "${tvalue}" ] && (( (sel & INDEX_BIT) == 0 )) && ((sel+=INDEX_BIT)) && selection_string+="${tvalue} "
                    [ "idp"   = "${tvalue}" ] && (( (sel & IDP_BIT) == 0 )) && ((sel+=IDP_BIT)) && selection_string+="${tvalue} "
                    shift
                done
                [ -z "${selection_string}" ] && echo "Unknown Node Type: [${tvalue}], Sorry :-(" && exit 1;
                echo "node type set to: [ $selection_string] (${sel}) "
                unshift=1
                ;;
            --set-type)
                let sel=0
                local tvalue
                shift
                until [ -z "$1" ]; do
                    tvalue=$(echo "$1" | tr 'A-Z' 'a-z')
                    #turn on the proper bit when string is detected
                    [ "all"   = "${tvalue}" ] && sel=$ALL_BIT && selection_string="all " && shift && break
                    [ "data"  = "${tvalue}" ] && ((sel+=DATA_BIT))  && selection_string+="${tvalue} "
                    [ "index" = "${tvalue}" ] && ((sel+=INDEX_BIT)) && selection_string+="${tvalue} "
                    [ "idp"   = "${tvalue}" ] && ((sel+=IDP_BIT))   && selection_string+="${tvalue} "
                    shift
                done
                [ -z "${selection_string}" ] && echo "Unknown Node Type: [${tvalue}], Sorry :-(" && exit 1;
                echo "node type set to: [ $selection_string] (${sel}) "
                set_sel ${sel}
                exit 0
                ;;
            --get-type)
                read_sel
                show_type
                exit 0
                ;;
            start | --start)
                shift
                (( $# != 0 ))  && echo "error: \"start\" must be the last argument in the arg sequence, Sorry :-(" && exit 1
                check_prerequisites
                [ $? != 0 ] && echo && exit 1
                ((DEBUG)) && echo "START SERVICES (${sel})"
                start ${sel}
                exit 0
                ;;
            stop | --stop)
                shift
                (( $# != 0 )) && echo "error: \"stop\" must be the last argument in the arg sequence, Sorry :-(" && exit 1
                check_prerequisites
                [ $? != 0 ] && echo && exit 1
                (($DEBUG)) && echo "STOP SERVICES"
                stop ${sel}
                exit 0
                ;;
            restart)
                shift
                (( $# != 0 )) && echo "error: \"restart\" must be the last argument in the arg sequence, Sorry :-(" && exit 1
                check_prerequisites
                [ $? != 0 ] && echo && exit 1
                stop ${sel}
                sleep 2
                start ${sel}
                exit 0
                ;;
            update | --update | upgrade | --upgrade )
                shift
                (( $# != 0 )) && echo "error: \"update\" must be the last argument in the arg sequence, Sorry :-(" && exit 1
                self_verify
                init
                check_prerequisites
                [ $? != 0 ] && echo && exit 1
                
                read_sel

                #---------------
                #version checking...
                #---------------
                setup_curl
                setup_git
                setup_java
                setup_ant
                setup_postgress
                #TODO: no check for cdat yet :-(
                setup_esgcet

                #The arg "1" indicates an upgrade (see functions)
                setup_tomcat 1

                [ $((sel & DATA_BIT)) != 0 ] && (( ! no_globus )) && echo "setup_globus [${DATA_BIT}]" && setup_globus ${DATA_BIT} ${gridftp_config_args}
                [ $((sel & IDP_BIT )) != 0 ] && (( ! no_globus )) && echo "setup_globus [${IDP_BIT}]" && setup_globus ${IDP_BIT} ${myproxy_config_args}
                [ $((sel & INDEX_BIT)) != 0 ] && setup_subsystem search esg-search 1

                #The arg "1" indicates an upgrade (see function)
                setup_node 1

                #---
                start ${sel}

                exit 0
                ;;
            --write-env)
                (( (sel & WRITE_ENV_BIT) == 0 )) && ((sel+=WRITE_ENV_BIT))
                echo
                ;;
            -v | --version)
                echo "Version: $version"
                echo "Earth Systems Grid Federation (http://esgf.org)"
                echo "ESGF Node Installation Script"
                echo "Lawrence Livermore National Laboratory"
                echo ""
                exit 0
                ;;
            --verbose) 
                VERBOSE=1
                ;;
            --clear)
                self_verify
                check_prerequisites
                [ $? != 0 ] && echo && exit 1
                if [ -e ${envfile} ]; then 
                    mv -v ${envfile} ${envfile}.bak
                    echo "Cleared envfile ${envfile}"
                fi
                exit 0
                ;;
            --clear-certs)
                self_verify
                check_prerequisites
                [ $? != 0 ] && echo && exit 1
                init
                echo "Clearing out certs..."
                local cert_dir=${HOME}/.globus/certificates-esg
                [ -e ${cert_dir} ] && rm -rf ${cert_dir}
                exit 0
                ;;
            --test-pub)
                init
                shift
                echo "test_publication" && test_publication $@
                exit
                ;;
            --info)
                info
                exit
                ;;
            --check)
                shift
                self_verify $1 && echo "$0 is up-to-date"
                exit $?
                ;;
            --config-db)
                self_verify
                init
                check_prerequisites
                [ $? != 0 ] && echo && exit 1
                
                configure_postgress 
                exit $?
                ;;
            --uninstall)
                check_prerequisites
                [ $? != 0 ] && echo && exit 1
                init
                uninstall
                exit
                ;;
            --register)
                self_verify
                init
                #First arg is the server
                #Second arg is the password (not required)
                shift
                register $1 $2
                exit
                ;;
            --fetch-esg-certs)
                self_verify
                shift
                init
                id | grep root >& /dev/null
                [ $? != 0 ] && printf "[FAIL] \n\tMust be root for this option\n\n" && exit 1
                fetch_esg_certificates
                exit $?
                ;;
            --rebuild-truststore)
                shift
                (( $# != 0 ))  && echo "error: \"--rebuild-truststore\" must be the last argument in the arg sequence, Sorry :-(" && exit 1
                self_verify
                init
                id | grep root >& /dev/null
                [ $? != 0 ] && printf "[FAIL] \n\tMust be root for this option\n\n" && exit 1
                rebuild_truststore
                exit $?
                ;;
            --add-my-cert-to-truststore)
                self_verify
                shift
                init
                id | grep root >& /dev/null
                [ $? != 0 ] && printf "[FAIL] \n\tMust be root for this option\n\n" && exit 1
                add_my_cert_to_truststore $@
                exit $?
                ;;
            --generate-ssl-key-and-csr)
                self_verify
                shift
                init
                id | grep root >& /dev/null
                [ $? != 0 ] && printf "[FAIL] \n\tMust be root for this option\n\n" && exit 1
                #arg 1  -> what we want to name the private key
                #arg 2  -> what we want to name the public cert
                #arg 3  -> (what we want to DN to be for the public cert)
                #arg 4  -> (keystore password)
                #(no args necessary, all args have defaults)
                generate_ssl_key_and_csr $@
                exit $?
                ;;
            --install-keypair)
                self_verify
                shift
                init
                id | grep root >& /dev/null
                [ $? != 0 ] && printf "[FAIL] \n\tMust be root for this option\n\n" && exit 1
                install_keypair $@
                exit $?
                ;;
            #*************
            #(deprecated)
            #*************
            --install-signed-cert)
                self_verify
                shift
                init
                id | grep root >& /dev/null
                [ $? != 0 ] && printf "[FAIL] \n\tMust be root for this option\n\n" && exit 1
                install_signed_certificate $@
                exit $?
                ;;
            #*************
            #(deprecated)
            #*************
            --export-keys-to-globus)
                shift
                init
                id | grep root >& /dev/null
                [ $? != 0 ] && printf "[FAIL] \n\tMust be root for this option\n\n" && exit 1
                export_keystore_as_globus_hostkeys
                exit $?
                ;;
            --prefix)
                local pvalue
                shift
                until [ $(echo $1 | egrep '^\s*--') ] || [ -z "$1" ] || [ "$1" = "stop" ] || [ "$1" = "start" ] || [ "$1" = "status" ] || [ "$1" = "restart" ] || [ "$1" = "update" ]; do
                    pvalue="$1"
                    (($DEBUG)) && echo "prefix value is: $1"
                    shift
                done
                unshift=1
                install_prefix=${pvalue}
                [ -z "${pvalue}" ] && printf "\nERROR: Did not properly set --prefix value!!!\n\n" && exit 1
                ;;
            --workdir)
                local wvalue
                shift
                until [ $(echo $1 | egrep '^\s*--') ] || [ -z "$1" ] || [ "$1" = "stop" ] || [ "$1" = "start" ] || [ "$1" = "status" ] || [ "$1" = "restart" ]  || [ "$1" = "update" ]; do
                    wvalue="$1"
                    (($DEBUG)) && echo "workdir value is: $1"
                    shift
                done
                unshift=1
                workdir=${wvalue}
                [ -z "${wvalue}" ] && printf "\nERROR: Did not properly set --workdir value!!!\n\n" && exit 1
                ;;
            --no-globus)
                no_globus=1
                ;;
            --force)
                force_install=1
                ;;
            --gridftp-config)
                (( (sel & DATA_BIT) == 0 )) && echo "Sorry, the --gridftp flag may only be used for \"node\" type commands" && exit 1
                #acceptable args:  "with-bdm-config" | "bdm-config-only"
                #Gather up tokens after this switch as long as the
                #subsequent tokens do not start with "--"
                local tmpargs=""#array to store args for this switch.
                local let index=0
                shift
                until [ $(echo $1 | egrep '^\s*--') ] || [ -z "$1" ] || [ "$1" = "stop" ] || [ "$1" = "start" ] || [ "$1" = "status" ] || [ "$1" = "restart" ] || [ "$1" = "update" ]; do
                    tmpargs[((index++))]=$1
                    (($DEBUG)) && echo "added $1 to args list: ${tmpargs[@]}"
                    shift
                done
                unshift=1
                [ "${#tmpargs}" = 0 ] && printf "\n\n must follow --gridftp-config with proper flag(s)! \n\n" && usage
                gridftp_config_args=${tmpargs[@]}
                unset tmpargs
                ;;
            --myproxy)
                (( (sel & IDP_BIT) == 0 )) && echo "Sorry, the --myproxy flag may only be used for \"idp\" type commands" && exit 1
                #acceptable args:  [gen-self-cert] <dir> | [regen-simpleca] [fetch-certs|gen-self-cert|keep-certs] | [install|update]
                #Gather up tokens after this switch as long as the
                #subsequent tokens do not start with "--"
                local tmpargs=""#array to store args for this switch.
                local let index=0
                shift
                until [ $(echo $1 | egrep '^\s*--') ] || [ -z "$1" ] || [ "$1" = "stop" ] || [ "$1" = "start" ] || [ "$1" = "status" ] || [ "$1" = "restart" ] || [ "$1" = "update" ]; do
                    tmpargs[((index++))]=$1
                    (($DEBUG)) && echo "added $1 to args list: ${tmpargs[@]}"
                    shift
                done
                unshift=1
                [ "${#tmpargs}" = 0 ] && printf "\n\n must follow --myproxy with proper flags! \n\n" && usage
                myproxy_config_args=${tmpargs[@]}
                unset tmpargs
                ;;
            status | --status)
                status
                exit $?
                ;;
            -h | --help)
                usage
                ;;
            *)
                printf "\n ERROR: unknown switch $1 \n\n" && exit 1
                ;;
        esac
        ((!unshift)) && shift
    done

    check_prerequisites
    [ $? != 0 ] && echo && exit 1

    self_verify

    (($DEBUG)) && echo "SEL = $sel"
    [ $((sel)) == 0 ] && usage

    echo
    echo "-----------------------------------"
    echo "ESGF Node Installation Program"
    echo "-----------------------------------"
    echo 

    info

    local doit="n"
    read -p "Are you ready to begin the installation? [Y/n] " doit
    if [ "${doit}" = "N" ] || [ "${doit}" = "n" ] || [ "${doit}" = "no" ]; then
        exit 0
    fi    

    init
    read_sel

    (( force_install ))  && echo "(force install is ON)"
    (( (sel & DATA_BIT ) != 0)) &&  echo "(data node type selected)"
    (( (sel & INDEX_BIT ) != 0)) && echo "(index node type selected)"
    (( (sel & IDP_BIT ) != 0)) &&   echo "(idp node type selected)"
    #---------------------------------------
    #Installation of basic system components.
    # (Only when one setup in the sequence is okay can we move to the next)
    #---------------------------------------
    [ $((sel & INSTALL_BIT)) != 0 ] && setup_curl
    [ $((sel & INSTALL_BIT)) != 0 ] && setup_git
    [ $((sel & INSTALL_BIT)) != 0 ] && setup_java
    [ $((sel & INSTALL_BIT)) != 0 ] && setup_ant
    [ $((sel & INSTALL_BIT)) != 0 ] && setup_postgress
    [ $((sel & TEST_BIT))    != 0 ] && test_postgress
    [ $((sel & INSTALL_BIT)) != 0 ] && [ $((sel & DATA_BIT)) != 0 ] && setup_cdat
    [ $((sel & INSTALL_BIT)) != 0 ] && [ $((sel & DATA_BIT)) != 0 ] && setup_esgcet
    [ $((sel & TEST_BIT))    != 0 ] && [ $((sel & DATA_BIT)) != 0 ] && test_esgcet
    [ $((sel & INSTALL_BIT)) != 0 ] && setup_tomcat ${keystore_password}
    [ $((sel & TEST_BIT))    != 0 ] && test_tomcat
    [ $((sel & INSTALL_BIT)) != 0 ] && [ $((sel & DATA_BIT)) != 0 ] && setup_tds 
    [ $((sel & TEST_BIT))    != 0 ] && [ $((sel & DATA_BIT)) != 0 ] && test_tds 
    [ $((sel & INSTALL_BIT)) != 0 ] && setup_node #(tomcat off)

    #---------------------------------------
    #Installation of "plugin" subsystems... & filters
    #---------------------------------------
    #---filters------
    [ $((sel & INSTALL_BIT)) != 0 ] && [ $((sel & DATA_BIT)) != 0 ] && echo "security filters subsystem (TOKEN)" && setup_subsystem security-token-filters filters $@
    [ $((sel & INSTALL_BIT)) != 0 ] && [ $((sel & DATA_BIT)) != 0 ] && echo "security filters subsystem (SAML/ORP)"  && setup_subsystem security-tokenless-filters filters $@
    #---subsystems--- 
    [ $((sel & INSTALL_BIT)) != 0 ] && [ $((sel & DATA_BIT)) != 0 ] && echo "orp security subsystem" && setup_subsystem orp orp $@
   #[ $((sel & INSTALL_BIT)) != 0 ] && [ $((sel & DATA_BIT)) != 0 ] && echo "drslib subsystem"  && setup_subsystem drslib esgf-drslib $@


    #---------------------------------------
    # Globus Installation...
    #---------------------------------------
    [ $((sel & INSTALL_BIT)) != 0 ] && [ $((sel & DATA_BIT+IDP_BIT)) != 0 ] && (( ! no_globus )) && echo "setup_globus [${DATA_BIT}]" && setup_globus ${DATA_BIT} ${gridftp_config_args}
    [ $((sel & TEST_BIT))    != 0 ] && [ $((sel & DATA_BIT+IDP_BIT)) != 0 ] && (( ! no_globus )) && echo "test_globus [${IDP_BIT}" && test_globus ${IDP_BIT} ${myproxy_config_args}


    #---------------------------------------
    # Gateway type install...
    #---------------------------------------
    [ $((sel & INSTALL_BIT)) != 0 ] && [ $((sel & INDEX_BIT)) != 0 ] && echo "search subsystem" && setup_subsystem search esg-search $@
    [ $((sel & TEST_BIT)) != 0 ]    && [ $((sel & INDEX_BIT)) != 0 ] && echo "test search subsystem" && \
        source ${scripts_dir}/esg-search >& /dev/null && test_search_services

    #---------------------------------------
    # Publishing Test...
    #---------------------------------------
    [ $((sel & TEST_BIT)) != 0 ] && [ $((sel & DATA_BIT)) != 0 ] && echo "test_publication" && test_publication


    #---------------------------------------
    #Summary and Installation Housekeeping...
    #---------------------------------------
    [ $((sel & INSTALL_BIT))   != 0 ] && echo "show_summary" && show_summary 
    [ $((sel & WRITE_ENV_BIT)) != 0 ] && echo "write_env" && write_env && exit 0
    

    #---------------------------------------
    #System Launch...
    #---------------------------------------
    start ${sel}
    done_remark
    echo 
}

esg_node_finally() {
    echo "(esg_datanode: cleaning up etc...)"
    chown -R ${installer_uid}:${installer_gid} ${X509_CERT_DIR} >& /dev/null
    chown -R ${installer_uid}:${installer_gid} ${HOME}/.globus >& /dev/null
    reset
    exit 0
}

#Set system traps
trap esg_node_finally INT TERM

[ -w "${logfile}" ] && echo "start time: `date`" >> ${logfile}
main $@
trap - INT TERM
esg_node_finally
[ -w "${logfile}" ] && echo "end time: `date`" >> ${logfile}
